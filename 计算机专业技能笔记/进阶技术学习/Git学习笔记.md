# Git学习笔记

&emsp;&emsp;*摘要：本篇笔记的主要内容时在学习Git时做的学习记录，因为最近开始频繁的进行团队协作开发，因此对于Git的使用也逐渐频繁了起来，为了更好的适应这种团队开发环境，提升自己的团队协作能力，我打算好好的学习一遍Git，本篇笔记的学习基础是尚学堂的Git课程，因此内容可能和它们的教程比较吻合*。

[TOC]



## 课程介绍

```
课程介绍

1.Git介绍 Git - 分布式版本控制工具，初次以外还存在集中式版本控制工具
2.Git安装，在Windows上安装Git
3.Git命令，基于开发案例学习Git的常用命令
4.Git分支，分支是Git的主打特性，只要使用Git，那必然是离不开分支的。分支中存在：分支特性，分支创建，分支转换，分支合并几种特性。在分支合并中还存在代码合并冲突的问题，因此还学习了分支合并的冲突及其解决方案。
5.IDEA集成Git
-----------------------GitHub-------------------------
6.GitHub，GitHub是Git官方的代码托管中心，是在服务器上托管代码的，因此这个东西很重要，要重点学习，在使用Git中push，pull和clone是三个很重要且基础的语句，要好好学习。
7.GitHub的SSH免密登录
8.IDEA集成GitHub
-----------------------Gitee-------------------------
9.Gitee的学习，码云创建远程库，IDEA连接码云进行代码推送(IDEA集成码云)
10.码云连接GitHub进行代码的复制和迁移
-----------------------GitLab-------------------------
11.GetLab的学习，GitLab是一个基于局域网的代码版本管理工具，如果代码不开源的话，有些公司很可能使用这种管理工具
12.GitLab服务器的搭建和部署
13.IDEA集成GitLab

课程目标：5小时熟练掌握Git，GitHub，Gitee码云的使用
```



## 1.Git概述

&emsp;&emsp;Git是一个免费的，开源的分布式版本控制系统，可以快速高效的处理从小到大的各种项目，现在越来越多的团队开始使用Git来对自己的项目进行管理。

&emsp;&emsp;Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。

&emsp;&emsp;*在Git的官网中提到了一句话：Everything is local，也就是说一切都在本地，这句话描述的是Git的分布式，我们在了解一个新技术之前，一定要去看看它的官网，这对我们了解它有着不小的好处*。

### 1.1.什么是版本控制

&emsp;&emsp;版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。其最重要的功能就是可以记录文件修改历史记录，进而能够让用户查看历史版本，以便进行版本的管理，版本的回滚以及切换。

&emsp;&emsp;在早期人们是使用手动的方式管理文件的，人们在进行项目开发或者文档生成的时候，通常会产生项目迭代的现象，比如我们在修改论文的时候，往往会出好几版论文，有些细心的同学会根据修改日期分类，分出好几版，就像下图这样：

![image-20220721223029951](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220721223029951.png)

&emsp;&emsp;这种通过复制再修改的方法生成出好几版的方式，也就是说根据修改确定版本，并且进行不同的命名加以保存，以便于根据需求进行版本的回溯的行为，就叫做版本控制，上图这种做法就属于早期的版本控制，在人类计算机时代早期开发中，也是使用过这种版本控制的。上图中的论文虽然做了版本控制，但实际上用起来也仅仅能满足个人使用，即使是个人使用，实际上也是非常麻烦，因为随着版本的反复迭代，这些文件就会越来越多，最终多到我们想找一个版本时很不好找的程度，我们在修改论文的时候如果碰上一个认真负责的老师，问题可能就复杂了，因此在日益复杂的开发学习中，我们就不能使用这种多副本的方式进行版本控制了，我们需要使用版本控制系统了，关于这个问题我们在下一个模块进行详细的分析。

### 1.2.为什么需要版本控制

&emsp;&emsp;尽管在上图中这么写，我相信很多人并没有在毕业论文中这么做，并没有按照这样的版本控制方式写，但是随着我们年龄的增长，逐渐踏入职场，我们开始不得不使用版本控制思想，并且使用版本控制软件，这是为什么呢？这是因为我们**开始从个人开发过渡到团队协作了**，在实际开发纷繁复杂的版本迭代中，我们个人开发尚且都要一团乱麻了，更何况加上了团队协作，很多人要共同开发同一套代码，此时问题就更加复杂了，所以在此时我们必须使用版本控制，并且使用版本控制工具。

&emsp;&emsp;在这里课程中给出了一个例子：

![](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220722085859905.png)

&emsp;&emsp;当两个人共同开发同一个项目的时候，首先要将项目从公司的服务器上拷贝下来，然后两个人再开始书写，此时如果A下载的同时B也把代码下载了下来，并且进行了同时开发，然后再同时提交的话，如果没有版本控制工具，就会形成两个版本，而两人开发的又是重复资源的话，就会发生后提交的人把先提交的人提交的内容覆盖的情况，而先提交的人的版本就会发生丢失，这种情况在严谨的版本控制思想下是不能有的，因为我们应该保证能够找到所有的版本，我们此时应该是有：**A提交的版本，B提交的版本，A和B的合并版本**才行，因此我们需要使用到版本控制，并且需要使用到足够先进的版本控制软件了。

&emsp;&emsp;综上所述，我们在公司里使用多副本版本控制模式进行版本控制显然是不靠谱的，我们需要使用git这样的先进的适合团队的版本控制工具。

### 1.3.版本控制工具

&emsp;&emsp;版本控制工具大体上可以分为两种：**集中式的版本控制工具**和**分布式的版本控制工具**，现在让我们看看这两种类型的版本控制工具有什么区别。

#### 1.集中式版本控制工具

&emsp;&emsp;CVS，SVN，VSS...

&emsp;&emsp;集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，并且这种集中式的版本控制工具会保存所有文件的修订版本，做好冲突管理以及版本控制，协同工作的人们通过客户端连接到这台服务器，取出最新的文件或者提交更新，这样完成一次次的协同工作以及项目版本管理。长期以来很多公司都是使用的这种管理模式。

![image-20220722211657730](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220722211657730.png)

&emsp;&emsp;如上图所示，就是一个典型的集中控制的样例。首先在公司中肯定有多个成员，图中的多台电脑，就代表我们体系中的多个程序员，这些人共同开发同一套代码，在整个体系中存在一个中央服务器，在这个中央服务器中保存着我们项目中所有的代码，无论是谁想要对这个代码进行更改开发，都必须要从这个中央服务器中下载代码，这样一来我们可以保证整个团队中的人都修改的是同一套代码。开发完毕之后提交到服务器上，服务器中的管理工具会处理每个人的提交。

&emsp;&emsp;这种做法实际上是很有好处的，每个人都可以在一定程度上看到项目中的其他人正在做什么。管理员也可以轻松的掌握每个开发者的权限，并且管理一个集中化的版本控制系统，肯定是比在哥哥客户端上维护本地数据库轻松容易的多。大家看的都是同一套项目，而项目最终也是在一个地方，整体管理起来会容易的多。

&emsp;&emsp;但是使用这中单点保存的模式也是存在着一个致命的缺陷的，那就是我们所有的数据都被保存到了中央服务器上，当中央服务器坏了的时候，我们的版本控制就完全终止了，我们的版本就不能提交到中央服务器了。此时虽然我们可以在本地进行修改，但是只要我们没有把我们修改的代码版本提交到云端，云端就没有办法记录到我们的版本更新，整体的版本控制就没有在正常进行，在云端就会丢失版本，进而失去对版本的精确控制，此时我们书写的代码就没有意义，不符合版本控制的思想。因此这种集中式的版本控制就越来越少被使用了。大家逐渐把目光转移到了git这样的分布式版本管理工具上。

#### 2.分布式版本控制工具

![image-20220722213217699](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220722213217699.png)

&emsp;&emsp;如图所示，就是一个典型的分布式版本控制工具，在分布式结构中，已经没有中央服务器了，每个程序员的个人电脑就是一个人的代码库，我们可以在自己的电脑上做版本控制，每个人拥有一个本地库，而每个人就可以在自己的本地库上做版本控制。但是话又说回来了，我们每个人都有一个自己的本地库，在本地库上做版本控制，又如何保证代码的统一性呢？

&emsp;&emsp;每一个分布式的版本控制工具都是有一个远程的代码托管中心的，我们俗称远程库，其实现方式类似中央服务器，但是其地位和服务器远远不一样，这个远程库是我们对代码进行合并管理的一个位置。如A写了一个代码版本，就可以把代码先推送到远程库中，而B想要继续开发代码，就需要先从远程库中先克隆一份代码，克隆到本地仓库之后再进行修改，修改完毕之后还要把本地仓库的代码推送到远程库，进而时刻保证远程库中的代码是最新的。

&emsp;&emsp;那么问题又来了，当远程仓库挂了怎么办呢？首先远程仓库都是大公司运营的，一般情况下不会挂，即使挂了，我们的版本控制工具也在本地，我们可以在本地进行版本控制，记录我们代码的每一个版本，等到远程仓库恢复之后，我们会直接把代码推送到远程库中，而本地库中版本记录信息当然也会一并被推送到远程库中。

&emsp;&emsp;分布式的版本控制系统出现以后，解决了集中式版本控制系统的缺陷：

1. 服务器断网的情况下也可以进行开发(因为版本控制实在本地进行的，版本的信息先保存在本地，然后再推送到云端)
2. 每个客户端保存的都是整个完整的项目(包含历史记录，更加安全)

&emsp;&emsp;但是也存在一些问题，比如权限问题，因为每个人手里都有完整的代码，我们就拥有全部代码的访问权限

### 1.4.Git的历史

![image-20220722215142426](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220722215142426.png)

&emsp;&emsp;Git是在Linux的开源开发中产生的，具体是如何产生的网上有一大堆，主要是供需关系以及复杂的社会因素造成的，最终造就了一个非常好用的版本控制工具，世界真是神奇。

&emsp;&emsp;值得一提的是因为Git是和Linux一家做的，所以二者二者关系实际上是非常紧密的，实际上，Linux中是自带Git的，Git和Linux的融合度很高，而和Linux系统十分相似的MacOS系统中，也是自带Git的，使用这两种系统都能直接享受到Git的功能。

&emsp;&emsp;随着时间的推移，GitHub出现了，GitHub是Git的官方远程库，大大促进了开源项目的发展，里边存在各种各样好的开源项目。

### 1.5.Git工作机制

![image-20220722215159390](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220722215159390.png)

&emsp;&emsp;Git的功能虽然十分强大，但是其工作机制十分简单，上图中就是Guit的基本工作机制。在Git中分为三个区域：**工作区**，**暂存区**，**本地库**。

#### 1.5.1.工作区

&emsp;&emsp;工作区就是我们写代码的地方，但是工作区可不是指的是我们的开发工具写代码的地方，而是指我们书写的代码存放的目录的位置，也就是说我们书写代码所在那个目录，这个存放代码的地方被我们称之为工作区。

#### 1.5.2.暂存区

&emsp;&emsp;我们在工作区写了代码之后，我们需要让Git追踪到这个代码文件，因此我们需要将工作区的代码添加但暂存区，我们此时需要使用add指令将这个代码文件添加到暂存区。既然是暂存区，就是临时存储，那它内部的代码就是可以删除掉的，而工作区的代码也是可以删除的。**需要注意的是在工作区对代码进行删除修改，删掉就是删掉了，对于这个版本是没有历史记录的，也没有历史版本**。**同样的，我们在暂存区对代码进行删除修改，也是没有历史记录的**。**但是我们只要将暂存区的内容提交到了本地库，使用commit提交到了本地库，就会生成历史版本，此时我们的代码就删不掉了，我们在代码中写了啥都会被保存，都删除不掉了，因为这时我们的代码已经被版本控制工具管理上了，所以这时在本地库中就会生成一个对应的历史版本来标记我们这次提交的版本，而这个版本会作为一个版本历史永远存在，我们无法删除**。

#### 1.5.3.本地库

&emsp;&emsp;本地库就是管理我们本地的项目版本的地方，本地库是一个只增不删的地方，只要向这里进行提交，就会自动生成一个git中的历史版本，这些历史版本是删除不了的，因为为了保险起见这里的所有版本都要被保留，项目一旦被提交到这个位置，就会作为一个历史版本永久被保存，以便于用户找到它们，因此我们一定要谨慎的提交。

&emsp;&emsp;因为在本地库中的各种版本都是相互关联，相互依据的，所以我们不能单独删掉一个历史版本，想要进行删除的话，我们只能是直接把整个本地库删除，但是这样一来我们的所有版本都会丢失，这样的后果非常严重，所有我们的代码在提交本地库之前要慎重的检查。

### 1.6.Git和代码托管中心

&emsp;&emsp;代码托管中心是基于网络服务器的远程代码仓库，一般我们称之为远程库。远程库就是代码托管中心，GitHub就是一个代码托管中心，Gitee也是一个代码托管中心。远程库实际上也是Git的一部分，当我们将暂存区的代码提交到本地仓库形成历史版本之后，我们还可以将本地库中的历史版本**推送**到远程仓库中，当我们把不该写的东西推送到远程库中之后，我们就彻底无法修改了。

&emsp;&emsp;Git的仓库中的内容**是以历史版本记录的形式存在的**，里边的代码都是以历史版本记录的形式保存，我们只要提交一次，就会根据我们的提交生成一个相应的历史版本记录，当我们推送时，也是将这些历史版本记录推送上去。

&emsp;&emsp;Git的代码托管中心基本上分为两类：基于互联网的代码托管中心和基于局域网的代码托管中心。其中基于互联网的代码托管中心有GitHub和Gitee，基于局域网的代码托管中心有GitLab。GitLab时一个需要使用内部服务器进行搭建的局域网代码托管中心，如果某个公司是一个不开源的公司，并不想让大家分享到自己的项目代码，但是又需要让员工有一个远程库，就可以使用公司自己的服务器，搭建一个自己的代码托管中心，员工使用局域网对项目进行提交。

## 2.Git安装

&emsp;&emsp;接下来我们简述一下Git的安装，首先我们登录[Git (git-scm.com)](https://git-scm.com/)，这是Git的官方网站：

![image-20220723141635098](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723141635098.png)

&emsp;&emsp;进入之后是这样的界面，点击红色方框中的图标，就可以下载当前最新版的Git，下载下来之后我们直接点击安装程序，之后就会弹出这样的弹窗：

![image-20220723141905208](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723141905208.png)

&emsp;&emsp;这个就是一个条款，这个我们直接next就行，然后就是安装路径了：

![image-20220723141951645](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723141951645.png)

&emsp;&emsp;我们最好将其安装在一个非中文，没有空格的目录之下，且最好不要往C盘安装。之后是安装配置选项，这个我们一般直接默认选项啥也不动直接next就行，有需要的话也可以根据下面的中文提示进行自己想要的修改。

![image-20220723142044776](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723142044776.png)

&emsp;&emsp;之后是安装目录名称，修改这里可以更改安装目录的名称，不过一般情况下没必要修改，我们也是直接跳过即可：

![image-20220723142259855](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723142259855.png)

&emsp;&emsp;之后是Git的默认编辑器，我们一般情况下默认使用Git自带的Vim编辑器即可：

![image-20220723142409973](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723142409973.png)

&emsp;&emsp;再之后是默认分支名设置，我们一般默认选择让Git决定，分支名默认是master，然后直接下一步就行：

![image-20220723142520250](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723142520250.png)

&emsp;&emsp;修改Git的环境变量，我们选择第一个，不修改环境变量，只在Git Bash中使用Git，这里默认是选择第二个的，选择第二个的话可以让我们不止能够再Bash中使用Git，还可以在第三方软件如IDEA中以及Windows的命令行解释器中使用Git，这个根据自身需求勾选：

![image-20220723142644007](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723142644007.png)

&emsp;&emsp;选择后台客户端连接协议，这里直接选择默认值OpenSSL，然后直接下一步即可：

![image-20220723142819375](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723142819375.png)

&emsp;&emsp;配置Git文件的行末换行符，Windows使用CRLF（回车换行），Linux使用LF，我们选则第一个自动转换，然后继续下一步。选择第一个的话Git会为我们自动转换换行符，这样一来省的我们考虑平台之间的差异：

![image-20220723143020277](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143020277.png)

&emsp;&emsp;选择Git终端类型，选择默认的Git Bash终端，Git Bash中的命令喝Linux的终端中的一致，熟悉Linux的人用起来更舒服，熟悉Windows命令行的人也可以选择第一个，根据自身需求更改，选择后继续下一步：

![image-20220723143117529](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143117529.png)

&emsp;&emsp;选择Git pull合并的模式，这里就是当Git中出现代码冲突的时候Git提供的合并模式，我们一般选择默认，然后下一步：

![image-20220723143159235](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143159235.png)

&emsp;&emsp;选择Git的凭据管理器，选择默认的跨平台凭据管理器（Windows的已经过时了），这个和远程库的推送和拉取有关，是方便我们快速拉取的，选择后下一步：

![image-20220723143248618](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143248618.png)

&emsp;&emsp;其他配置，选择默认设置，然后下一步：

![image-20220723143318035](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143318035.png)

&emsp;&emsp;实验室功能，目前技术还不成熟，有已知的Bug，不勾选，点击`Install`按钮，开始安装

![image-20220723143436155](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143436155.png)

&emsp;&emsp;点击`Finish`按钮，安装成功！

![image-20220723143513557](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143513557.png)

&emsp;&emsp;安装成功的标志是我们鼠标右键的菜单栏中出现了下图中的两个东西：

![image-20220723143642141](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143642141.png)

&emsp;&emsp;点击Git Bash进入终端，输入git --version查看git版本，如果如图所示的话，就说明安装成功：

![image-20220723143828789](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723143828789.png)

## 3.Git常用命令

![image-20220723144543481](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723144543481.png)

### 3.1.设置用户签名

#### 3.1.1.基本语法

```shell
git config --global user.name 用户名
git config --global user.email 用户邮箱
```

#### 3.1.2.案例实操

![image-20220723145119843](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723145119843.png)

![image-20220723145158491](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723145158491.png)

&emsp;&emsp;需要注意的是这个邮箱是一个虚拟邮箱，Git不会检测这个邮箱是不是真的存在，只是作为一个用户的唯一标识使用。我们的配置信息也可以在`C:\Users\Administrator`找到：

![image-20220723145348755](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723145348755.png)

&emsp;&emsp;在这里可以看到我们的配置信息，我们也可以在这里直接修改。

&emsp;&emsp;PS:

```
	签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看
到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。
	※注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任
何关系。
```



### 3.2.初始化本地库

#### 3.2.1.基本语法

```shell
git init
```

#### 3.2.2.案例实操

![image-20220723145731413](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723145731413.png)

#### 3.2.3.结果

![image-20220723145803508](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723145803508.png)

&emsp;&emsp;这个`.git`文件是隐藏的，我们在查看中更改隐藏文件可视化选项就可以让其显示或者隐藏。

### 3.3.查看本地库状态

#### 3.3.1.基本语法

```shell
git status
```

#### 3.3.2.案例实操

![image-20220723150032295](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723150032295.png)

&emsp;&emsp;我们输入`git status`之后，会展示出三行日志：

```shell
On branch master
No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

&emsp;&emsp;第一行日志是提示我们当前的本地库所在的分支，可见我们本地库当前所在的分支位于master分支当中，在每一行的末尾我们也能看出所在的分支是master分支。

&emsp;&emsp;第二行展示的是提交状态，因为我们现在没有提交过，所以它说我们没有提交，是一个空的本地库。

&emsp;&emsp;第三行展示的是我们当前暂存区中是否存在需要提交的东西，因为是新库，所以它上面说我们现在没有需要提交的东西。

&emsp;&emsp;现在我们新建一个文件之后再看看状态有没有什么变化：

![image-20220723150643279](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723150643279.png)

![image-20220723150716524](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723150716524.png)

![image-20220723150749972](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723150749972.png)

&emsp;&emsp;现在我们来查看一下状态：

![image-20220723150829398](https://picgo-img-1303825935.cos.ap-beijing.myqcloud.com/lrbPic/image-20220723150829398.png)

```shell
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        hello.txt

nothing added to commit but untracked files present (use "git add" to track)

```

&emsp;&emsp;现在日志信息发生了变化，第二行中提示我们在当前目录下发现了未跟踪的文件，也就是出现了新的，没有被Git记录跟踪的文件。那这个文件既然没有被追踪，我们如何追踪它呢？在日志信息中也给出了追踪方法，那就是使用` git add`命令对其进行追踪。

### 3.4.添加暂存区

#### 3.4.1.将工作区的文件添加到暂存区

##### 1.基本语法

```
git add 文件名
```