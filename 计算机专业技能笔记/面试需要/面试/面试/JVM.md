# JVM

### Java虚拟机

 JVM（Java Virtual Machine），俗称Java虚拟机。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。 

java运行时的内存区域，线程独享，因为有jre,java编译class文件，class运行在jvm,不同的操作系统上jre可以针对翻译，jre适配了全部主流操作系统，

JVM的内部体系结构分为三部分

- 类装载器（ClassLoader）子系统
- [运行时数据区](#JVM内存模型)
- 执行引擎

## Java创建一个对象

#### 对象的创建

- ==指针碰撞：==有一段连续的区间，边界是两个指针（假设左右指针），分配一个对象，分配的地方就移动一定的字节数。如果发现左指针移动一定量的字节数后已经跟边界的右指针接触越过了，就会分配失败。（左右是相对的）
- 一边分配，一边垃圾回收，肯定会产生空间碎片，空间碎片的大小可能有足够大的空间在里面在去分配其他的对象。那么空闲链表就是来记录这些碎片的。
- ==空闲链表：==记录空闲，可用的空间。初始状态下，整个堆不就是一大块空闲空间嘛。为什么空闲列表这么好有的垃圾回收器，或者jvm有一部分还用指针碰撞呢，原因很简单，越好用的东西，管理起来就越麻烦，浪费的时间的越多。

#### 内存分布

- Header（对象头）：存储对象的原数据（无法直接操作）

  - 自身运行时的数据（Mark Word）（根据对象的状态来复用自己的空间，效果下图显示的淋漓尽致，里面的信息不一定全部存进去，可以只存进一部分，用来显示当前状态）

    1. 偏向时间戳

    2. 偏向线程ID

    3. 线程持有的锁

    4. 锁状态标志

    5. GC分代年龄（涉及垃圾回收）

    6. 对象哈希码（native方法）。

       ![](https://img-blog.csdnimg.cn/20190916171540108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lEXzE2MjAzMQ==,size_16,color_FFFFFF,t_70)

  - 指针类型：找到对象实例的元数据（所谓的元数据是指描述类与其他代码关系的代码介绍链接：[传送门](https://www.cnblogs.com/liuqk/articles/2115778.html)）

  - 数组长度：数组才有

- instanceData(实例数据)

  - 相同的字节数的会放到一块，父类数据放在子类数据之前。
  - 注意局部变量放在局部变量表中，而且是在运行期间才会进行读写操作。

- Padding （对齐填充）：填充内存的作用

  - 虚拟机有位数要求的时候，如果对象数据没有占够位数/倍数，用padding填空

#### 访问定位

- ==直接引用：==java栈中找到本方法的实例的时候，reference（存在于栈->栈帧->局部变量表->第0个位置（数组从零开始））存放堆中实例的引用。直接引用就是对象的堆中的实际地址，描述一个类需要类实例，类的一些描述，这些类描述存在方法区中。所以，使用直接引用的话，类的实例需要存储一个指向类描述的指针。

- ==句柄池：==类似于链接的中介，存放类实例的地址，类描述的地址。reference只需要指向本类的句柄池的位置，就可以得到两个引用。但是句柄池需要在堆中开辟出一块单独的空间来进行存储这些信息。

- 直接指针当然是速度快，不用在堆中进行中转。

  类的位置是会改变的，垃圾回收的时候，为了保持拥有连续的空间。经常会进行位置的移动，那么就需要进行指针的改变。

  使用句柄池的话，只需要改变句柄池的指针即可，不需要到栈中改变。为什么同样是改变指针，为什么句柄池会快。因为一次对象的移动涉及到很多个类，况且栈结构遍历很麻烦，很耗时间。

  鉴于这两个优缺点，可以在堆中使用句柄池，在方法区中使用直接引用。有一些虚拟机是把老年代放在方法区中的。

  这样也可以理解为什么句柄池放在堆中了。

## Java类加载过程

![image-20210718215436649](https://gitee.com/shen1shen1/pic-md1/raw/master/20210718215438.png)

### 加载

类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。

> **加载.class文件的方式**
>
> - 从本地系统中直接加载
> - 通过网络下载.class文件
> - 从zip，jar等归档文件中加载.class文件
> - 从专有数据库中提取.class文件
> - 将Java源文件动态编译为.class文件

### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。验证阶段大致会完成4个阶段的检验动作:

- ==文件格式验证==: 验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- ==元数据验证==: 对字节码描述的信息进行语义分析(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Object`之外。
- ==字节码验证==: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- ==符号引用验证==: 确保解析动作能正确执行。

### 准备

为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）

* 这个时候static int a=3; a的值是0 在接下来的初始化阶段才会赋值成3
* final修饰的会被赋值 final int b=4; //b

### 解析

虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）

**符号引用**就是一组符号来描述目标，可以是任何字面量。

**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:

- 声明类变量是指定初始值
- 使用静态代码块为类变量指定初始值

**JVM初始化步骤**

（先执行父类的，子类要想生成的话，先生成父类，所以是父类的静态先执行，然后是子类的静态，然后是父类的非静态块，父类的构造方法，子类的非静态块，子类的构造方法，需要注意的是，静态的只初始化一次，并且由这个类的第一个对象触发）

- 假如这个类还没有被加载和连接，则程序先加载并连接该类
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 假如类中有初始化语句，则系统依次执行这些初始化语句

**类初始化时机**: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:

- 创建类的实例，也就是new的方式
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射(如Class.forName("com.pdai.jvm.Test"))
- 初始化某个类的子类，则其父类也会被初始化
- Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类

### 使用

类访问方法区内的数据结构的接口， 对象是Heap区的数据。

### 卸载

**Java虚拟机将结束生命周期的几种情况**

- 执行了System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

## 类加载器， JVM类加载机制

### 类加载器的层次

![img](https://www.pdai.tech/_images/jvm/java_jvm_classload_3.png)

类加载器可以大致划分为以下三类 :

- 启动类加载器（Bootstrap ClassLoader）：负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。*
- 扩展类加载器（Extension ClassLoader）：负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（ Application ClassLoader）：负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：

- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得java class，例如数据库中和网络中

### 简述双亲委派机制

#### 工作原理

BootStrap

先检查有没有加载过这个类

如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果父类能够完成类的加载任务，就会成功返回，倘若父类加载器无法完成任务，子类加载器才会尝试自己去加载，这就是双亲委派模式。

#### 优势

安全性和性能。

- 首先它可以**避免类的重复加载**，当父亲已经加载了该类的时候，就没有必要子类加载器（ClassLoader）再加载一次。
- 其次是考虑到安全因素，**Java核心API中定义类型不会被随意替换**，假设通过网路传递一个名为java.lang.Integer的类，通过双亲委派的的模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字类，发现该类已经被加载，并不会重新加载网络传递过来的java.lang.Integer.而之际返回已经加载过的Integer.class，这样便可以防止核心API库被随意篡改。

### 破坏双亲委派

#### 第一次被破坏

jdk1.0没有双亲委派，所以jdk1.2引入时做了妥协，用户自定义的加载模型，所以被破坏

jdbc引入了一个上下文类加载器

OSGi 

[双亲委派模型和破坏性双亲委派模型详解_Enjoy博客-CSDN博客_破坏双亲委派模型](https://blog.csdn.net/luoyang_java/article/details/92598142) 

#### JDBC为何要破坏双亲委派

**因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。**

**JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。**DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，**根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。**也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。

#### Tomcat为什么要破坏双亲委派

Tomcat是个web容器 ，我们可能需要在一个Tomcat上部署两个项目，不同的项目可能会依赖同一个第三方类库的不同版本，如果我们使用默认的类加载机制，是无法加载两个相同类库的不同版本的。

为了热加载jsp，简单的说就是机器不用重启，只要部署上就能用。

**commonLoader**：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；
**catalinaLoader**：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
**sharedLoader**：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
**WebappClassLoader**：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；
从图中的委派关系中可以看出：

CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。

WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。

而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。

好了，至此，我们已经知道了tomcat为什么要这么设计，以及是如何设计的，那么，tomcat 违背了java 推荐的双亲委派模型了吗？答案是：违背了。 我们前面说过：

**双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。**

很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。

我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？
看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。牛逼吧。

## JVM内存模型

![img](https://gitee.com/shen1shen1/pic-md1/raw/master/image-20210813094938901.png)

==线程不安全区：==

**方法区**用于存储类信息，常量，静态变量等；

**堆**用于存放对象实例；

==线程安全区：==

程序计数器，本地方法栈，虚拟机栈是线程独享的。

**程序计数器**就是标记代码执行的行号，在线程切换后恢复到正确的执行位置；

**本地方法栈**是为虚拟机使用到的Native方法服务；

**虚拟机栈**描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

### **本地方法栈和程序计数器**（线程独享）

比如说我们点开Thread类的源码，会看到它的start0方法有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做**本地方法栈**的区域。

**程序计数器**其实就是一个指针，它指向了程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。

如果执行的是native方法，那这个指针就不工作了。

### **方法区**

方法区主要的作用就是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。

### **虚拟机栈和堆**

#### 区别

他们俩的**区别**就是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。

1、栈由系统自动分配，而堆是人为申请开辟; 

2、栈获得的空间较小，而堆获得的空间较大; 

3、栈由系统自动分配，速度较快,而堆一般速度比较慢;

4、栈是连续的空间，而堆是不连续的空间。

#### 虚拟机栈

它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈。

##### 虚拟机栈存在的异常

如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 **StackOverflowError** （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 **OutOfMemoryError**。

**虚拟机栈的生命周期**

对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。

这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。

**局部变量的复用**

局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。

虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。

#### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**。

> - **使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**
>
> 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
>
> - **PC寄存器为什么会被设定为线程私有的？**
>
> 多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。

#### 虚拟机栈

> Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

**作用**：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

**特点**：

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈**
- **栈不存在垃圾回收问题**

**栈中可能出现的异常**：

Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**

- 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 **StackOverflowError** 异常
- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常

#### 堆

##### 对象在堆中的生命周期

1. 在 JVM 内存模型的堆中，堆被划分为新生代和老年代 
   - 新生代又被进一步划分为 **Eden区** 和 **Survivor区**，Survivor 区由 **From Survivor** 和 **To Survivor** 组成
2. 当创建一个对象时，对象会被优先分配到新生代的 Eden 区 
   - 此时 JVM 会给对象定义一个**对象年轻计数器**（`-XX:MaxTenuringThreshold`）
3. 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） 
   - JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1
   - 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1
4. 如果分配的对象超过了`-XX:PetenureSizeThreshold`，对象会**直接被分配到老年代**

##### 对象的分配过程

为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。

1. new 的对象先放在eden区，此区有大小限制
2. 当eden的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对eden区进行垃圾回收（Minor GC），将eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到eden园区
3. 然后将eden中的剩余对象移动到survivor 0 区
4. 如果再次触发垃圾回收，此时上次幸存下来的放到survivor 0 区，如果没有回收，就会放到survivor 1 区
5. 如果再次经历垃圾回收，此时会重新放回survivor 0 区，接着再去survivor 1 区
6. 什么时候才会去老年代呢？ 默认是 15 次回收标记,进入老年代
7. 在老年代，相对悠闲。当老年代内存不足时，再次触发 Major GC，进行老年代的内存清理
8. 若老年代执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常

##### Minor GC、Major GC、Full GC

JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC）

- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 
  - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
  - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 
    - 目前，只有 CMS GC 会有单独收集老年代的行为
    - 很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 
    - 目前只有 G1 GC 会有这种行为
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

### JMM（Java内存模型）

#### 主内存与工作内存

Java内存模型规定了所有的变量都存储在==主内存==（Main Memory）中（此处的主内存与介绍物理 硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的==工作内存==（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的==主内存副本==，线程对变量的所有操作（读取、赋值等）都必须在工作内 存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变 量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图。

线程之间的共享变量存储在**主内存**中，每个线程都有一个私有的**本地内存**，本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。 

线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：

1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。

2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。

   ![*image-20210814101226060*](https://gitee.com/shen1shen1/pic-md1/raw/master/image-20210814101226060.png)

这里所讲的==主内存、工作内存==与第2章所讲的Java内存区域中的==Java堆、栈、方法区0==等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存 则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了 获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。 

#### Happens-Before(先行发生原则)

先行发生是Java内存模型中定义的两项操作之间的==偏序关系==，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的==影响==能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

**规则：**

1、程序顺序规则：一个线程中的每个操作happens-before于该线程中的任意后续操作

2、监视器锁（同步）规则：对于一个监视器的解锁，happens-before于随后对这个监视器的加锁

`**程序顺序规则中所说的每个操作happens-before于该线程中的任意后续操作并不是说前一个操作必须要在后一个操作之前执行，而是指前一个操作的执行结果必须对后一个操作可见，如果不满足这个要求那就不允许这两个操作进行重排序**`



## JVM相关

### JVM参数

**-Xms**：JVM启动时申请的初始Heap值，默认为操作系统物理内存的1/64但小于1G。默认当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过-XX:MaxHeapFreeRation=来指定这个比列。Server端JVM最好将-Xms和-Xmx设为相同值，避免每次垃圾回收完成后JVM重新分配内存；开发测试机JVM可以保留默认值。(例如：-Xms4g)

**-Xmx**：JVM可申请的最大Heap值，默认值为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列。最佳设值应该视物理内存大小及计算机内其他内存开销而定。(例如：-Xmx4g)

**-Xmn**：Java Heap Young区大小。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小(相对于HotSpot 类型的虚拟机来说)。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。(例如：-Xmn2g)、**

### JVM工具

**jps**：与linux上的ps类似，用于查看有权访问的虚拟机的进程，可以查看本地运行着几个java程序，并显示他们的进程号。当未指定hostid时，默认查看本机jvm进程。

**jinfo**：可以输出并修改运行时的java 进程的一些参数。

**jstat**：可以用来监视jvm内存内的各种堆和非堆的大小及其内存使用量。

**jstack**：堆栈跟踪工具，一般用于查看某个进程包含线程的情况。

**jmap：**打印出某个java进程（使用pid）内存内的所有对象的情况。一般用于查看内存占用情况。

**jconsole**：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视

### Tomcat和jvm的关系

1，JVM（虚拟机），相当于电脑安装系统一样，可以运行应用程序。让tomcat跑起来,就得有jdk，而jdk自带了JVM，安装完了jdk，把安装jkd的bin目录告诉tomca，就可以了。

2，有的web服务器不必安装jdk，因为自带了，如weblogic。

3，tomcat web容器，主要和有jsp和servlet有关， 没有tomcat， 通过一定技术是可以运行jsp和serlet，所以说JVM跑着tomcat，而没有JVM tomcat就废物了。

4，tomcat只是一个web容器，启动的时候，默认是不会去编译java及jsp code的，除非在你web工程的web.xml里配置了一些listener,然后在这些listner里，自己定义了一些关于jsp编译的操作。

 

前几天向unmi提问，今天他答复了。我觉得答复很清楚，在此记录下。总的来说 

1、一个tomcat是一个进程，其中有很多线程（与有多少个app无关） 

2、一个tomcat启动一个JVM，其中可以有很多APP 

3、一个tomcat中部署的多个app，虽然同处一个JVM里，但是由于无法相互调用，所以也可以认为是分布式的 