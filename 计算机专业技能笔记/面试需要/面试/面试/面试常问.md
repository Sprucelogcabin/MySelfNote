# 计网

###### 1,TCP和UDP的区别

![image-20220323153533351](C:\Users\qing  chun\AppData\Roaming\Typora\typora-user-images\image-20220323153533351.png)

###### 2，TCP三次握手过程

第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我

第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

###### 3，TCP四次挥手

第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；

第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；

第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；

第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。

###### 4，为什么要四次挥手

因为是双方彼此都建立了连接，因此双方都要释放自己的连接，A向B发出一个释放连接请求，他要释放链接表明不再向B发送数据了，此时B收到了A发送的释放链接请求之后，给A发送一个确认，A不能再向B发送数据了，它处于FIN-WAIT-2的状态，但是此时B还可以向A进行数据的传送。此时B向A 发送一个断开连接的请求，A收到之后给B发送一个确认。此时B关闭连接。A也关闭连接。

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是**关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送**。故需要**四步握手。**

### 操作系统内存管理

内存管理和虚拟内存管理：

	内存管理包括：
		程序装入等概念、
		交换技术、
		连续分配管理方式、
		非连续分配管理方式（分页、分段、段页式）。
	
	虚拟内存管理包括：
		虚拟内存概念、
		请求分页管理方式、
		页面置换算法、页
		面分配策略、
		工作集、
		抖动。
# get和post

（1），get的url有用户名和密码，post的没有，更安全一点。

（2），Get---->

-》通过url传递参数，url和参数之间用?隔开，参数之间用&隔开；

-》会将传输的数据显示在url中，不安全；

-》传输的数据量小，主要是因为url的长度受限制；

-》get一般用于直接获取数据，提高查询速度；

post---->

-》post的·数据在请求体内，不显示，所以安全；

-》post对上传数据的大小不限制，文件上传用post；

-》post适合用于增删改操作，因为快；

5，列举几种响应码；

200--->成功；

404--->文件不存在，一般是url有问题；

500--->服务器内部错误，java代码写的有问题；

# Java并发

## 死锁特征

发生死锁时，进程永远不能完成，系统资源被阻碍使用，以致于阻止了其他作业开始执行。在讨论处理死锁问题的各种方法之前，我们首先深入讨论一下死锁特点。

#### 必要条件

如果在一个系统中以下四个条件同时成立，那么就能引起死锁：

1. 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。
2. 占有并等待：—个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。
3. 非抢占：资源不能被抢占，即资源只能被进程在完成任务后自愿释放。
4. 循环等待：有一组等待进程 {P0，P1，…，Pn}，P0 等待的资源为 P1 占有，P1 等待的资源为 P2 占有，……，Pn-1 等待的资源为 Pn 占有，Pn 等待的资源为 P0 占有。

我们强调所有四个条件必须同时成立才会出现死锁。循环等待条件意味着占有并等待条件，这样四个条件并不完全独立。

## 死锁处理方法

一般来说，处理死锁问题有三种方法：

1. 通过协议来预防或避免死锁，确保系统不会进入死锁状态。
2. 可以允许系统进入死锁状态，然后检测它，并加以恢复。
3. 可以忽视这个问题，认为死锁不可能在系统内发生。


第三种解决方案为大多数操作系统所采用，包括 Linux 和 Windows。因此，应用程序开发人员需要自己编写程序，以便处理死锁。

### 锁的概念

#### lock

从底层角度看常见的锁也就两种：**Synchronized和Lock接口以及ReadWriteLock接口（读写锁）**

从类关系看出Lock接口是jdk5后新添的来实现锁的功能，其实现类：**ReentrantLock（可重入锁）、WriteLock、ReadLock。**

其实还有一个接口**ReadWriteLock，读写锁（读读共享、读写独享、写读独享、写写独享）**。

**Lock接口与synchronized关键字本质上都是实现同步功能。**

区别：

- **ReentrantLock（可重入锁）**：使用上需要显示的获取锁和释放锁，提高可操作性、可中断的获取获取锁以及可超时的获取锁，默认是非公平的但可以实现公平锁，悲观，独享，互斥，可重入，重量级锁。
- **ReentrantReadWriteLock**：默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入，重量级锁。
- **synchronized**：关键字，隐式的获取锁和释放锁，不具备可中断、可超时，非公平、互斥、悲观、独享、可重入的重量级

**Lock接口简介**

　　Lock锁是一种工具，用来控制对共享资源的访问。

　　Lock锁和Synchronized锁两者各个有各自的使用场景，lock并不是来替换Synchronized锁的。

　　Lock接口最常见的实现类是ReentrantLock

#### Sync和lock

- **存在层次：**syncronized是JAVA关键字，在jvm层面上，**Lock**是一个类
- **锁的释放：**
  - syncronized以获取锁的线程执行完同步代码，释放锁；线程执行发生异常，jvm会让线程释放锁；
  - Lock在finally中必须释放锁，不然容易造成线程死锁
- **锁的获取：**
  - syncronized假设A线程获得锁，B线程等待，如果A线程阻塞，B线程会一直等待
  - Lock分情况而定，Lock有多个锁获取的方式，大致可以尝试获取锁，线程可以不用一直等待
- **锁状态：**synchronized:无法判断**Lock:**可以判断
- **锁类型：**synchronized:可重入，不可中断，非公平**Lock**:可重入 可判断 可公平（两者皆可）
- **性能**synchroized:少量同步**Lock**：大量同步

#### AQS

AQS这个类在java.util.concurrent.locks包下，他是一个用来构建锁和同步器的框架，使用AQS能简单高效地构造出同步器，比如ReentrantLock、Semaphore。

#### AQS队列同步器

**队列同步器（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架**，它使用了 一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源的获取线程的排队工作。

同步器的主要使用方式是继承，子类通过继承同步器并实现他的抽象方法来管理同步状态。

**同步器的设计是基于模板方法模式的**，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法（这些模板方法将会调用使用者重写的方法）。

同步器提供的模板方法基本上分为3类，独占式获取锁与释放同步状态，共享式获取与释放同步状态，查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义

———————————————————————————

**队列同步器的实现**

1. **同步队列**	-	同步器依赖内部的同步队列（一个FIFO双向队列），当前线程获取同步状态失败的时候，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。
2. **独占式同步状态获取与释放** -  通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中中断操作时，线程不会从同步队列中移除。
3. **共享式同步状态获取与释放** - 共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。
4. **独占式超时获取同步状态** - 通过调用同步器的doAcquireNanos（int arg,long nanosTimeout）方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则返回false，该方法提供了传统java同步操作所不具备的特性



#### 公平锁/非公平锁

​    公平锁指多个线程按照申请锁的顺序来依次获取锁。非公平锁指多个线程获取锁的顺序并不是按照申请锁的顺序来获取，有可能后申请锁的线程比先申请锁的线程优先获取到锁，此极大的可能会造成线程饥饿现象，迟迟获取不到锁。由于**ReentrantLock是通过AQS来实现线程调度，可以实现公平锁**，但是synchroized是非公平的，无法实现公平锁



#### 乐观锁与悲观锁

   不是指什么具体类型的锁，而是指在并发同步的角度。**悲观锁**认为对于共享资源的并发操作，一定是发生修改的，哪怕没有发生修改，也会认为是修改的，因此对于共享资源的操作，悲观锁采取加锁的方式，认为，不加锁的并发操作一定会出现问题。

**乐观锁：**认为对于共享资源的并发操作是不会发生修改的，在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作共享资源是没问题的。



从上面的描述看除，乐观锁不加锁的并发操作会带来性能上的提升，悲观锁的使用就是利用synchroized关键字或者lock接口的特性。乐观锁在java中的使用，是无锁编程常常采用的是CAS自旋锁，典型的例子就是并发原子类，通过CAS自旋（spinLock）来更新值。

**悲观锁：**总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。



#### 独享锁与共享锁

**独享锁是指该锁一次只能被一个线程所持有。共享锁是指可被多个线程所持有**。在java中，对ReentrantLock对象以及synchroized关键字而言，是独享锁的。但是对于ReadWriteLock接口而言，其读是共享锁，其写操作是独享锁。读锁的共享锁是可保证并发读的效率，读写、写写、写读的过程中都是互斥的，独享的。独享锁与共享锁在Lock的实现中是通过 AQS（抽象队列同步器）来实现的。

#### 互斥锁与读写锁

互斥锁与读写锁就是具体的实现，互斥锁在java 中的体现就是synchronized关键字以及Lock接口实现类ReentrantLock，读写锁在java中的具体实现就是ReentrantReadWriteLock。

一次只有==一个线程==可以占有==写模式==的读写锁, 但是可以有==多个线程==同时占有==读模式==的读写锁. 正是因为这个特性,

当读写锁是==写加锁状态==时, 在这个锁被解锁之前, ==所有试图对这个锁加锁的线程都会被阻塞==.

当读写锁在==读加锁状态==时, 所有试图以读模式对它进行加锁的线程都可以==得到访问权==, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.

通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞随后的读模式锁请求, 这样可以避免读模式锁长期占用, 而等待的写模式锁请求长期阻塞.

读写锁适合于对数据结构的读次数比写次数多得多的情况. 因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁.

#### 可重入锁

又名递归锁，是指同一个线程在外层的方法获取到了锁，在进入内层方法会自动获取到锁。可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。对于ReentrantLock和synchronized关键字都是可重入锁的。**最大的好处就是能够避免一定程度的死锁。**

ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要**手动释放锁**，并且**加锁次数和释放次数要一样**。

#### 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，**对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作**。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，**ConcurrentHashMap中的分段锁称为Segment**，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即**内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)**。

当需要put元素的时候，并不是对整个hashmap进行加锁，而是**先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁**，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计size的时候，也就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。**分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。**



### CAS

**CAS是乐观锁，相关概念可以去查看乐观锁那里！！**

CAS是英文单词Compare And Swap的缩写，翻译过来就是**比较和交换**

**CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。**

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。



ABA问题例：比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A,并且线程two进行了一些操作将值变成了B,然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。**尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。**



从思想上来说，**Synchronized属于悲观锁**，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。



**CAS的缺点：**

1.CPU开销较大
 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

2.不能保证代码块的原子性
 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

3.ABA问题

### AQS

**AQS原理**
AQS：AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。
AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包

**AQS的核心思想**是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**

用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

**注意：AQS是自旋锁：**在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功

**实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物**



## 多线程

## 创建多线程的方式

无论有多少种形式，创建多线程的真正的方法，

其实只有两种：

         > 继承 Thread 类
    
        > 实现 Runnable 接口

其它形式都是这两种方式的变体。

### 继承 Thread 类

①实现方式
第一步：继承 Thread 类
第二步：重写 run() 方法
第三步：创建 Thread 子类对象
第四步：调用 start() 方法启动线程

##### ②start() 方法和 run() 方法区别

线程中的start()方法和run()方法的主要区别在于，当程序调用start()方法，将会创建一个新线程去执行run()方法中的代码。但是如果直接调用run()方法的话，会直接在当前线程中执行run()中的代码，注意，这里不会创建新线程。这样run()就像一个普通方法一样。

另外当一个线程启动之后，不能重复调用start()，否则会报IllegalStateException异常。但是可以重复调用run()方法。

总结起来就是run()就是一个普通的方法，而start()会创建一个新线程去执行run()的代码。

③评价
因为 Java 是单继承的，一个类继承了 Thread 类就不能继承其它类，所以通常不采用这个办法创建多线程。

###  实现Runnable接口

定义子类，实现Runnable接口。
子类中重写Runnable接口中的run方法。
通过Thread类含参构造器创建线程对象。
将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。
调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。

### 为什么需要多线程

CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:

- CPU 增加了缓存，以均衡与内存的速度差异；// 导致 `可见性`问题
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 `原子性`问题
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 `有序性`问题

### 并发编程的三个重要特性

1. **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized` 可以保证代码片段的原子性。
2. **可见性** ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。
3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

### 并发三要素

可见性、原子性、有序性

#### 可见性: CPU缓存引起

可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。

举个简单的例子，看下面这段代码：

```java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
```

假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

#### 原子性: 分时复用引起

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

经典的**转账问题**：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。

试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。

所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。

#### 有序性: 重排序引起

有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：

```java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

- ==编译器优化的重排序。==编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- ==指令级并行的重排序。==现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- ==内存系统的重排序。==由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

 ![img](https://www.pdai.tech/_images/jvm/java-jmm-3.png) 

上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

## 线程安全

 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，
就是线程安全的。

只要每个线程都能做到写后读（基于其他线程的计算结果进行计算），那么最后运算结果就一定是正确的。

加锁并不是一定就是线程安全，要看加完锁以后能不能保证写后读，如果是写完之前就释放了，那么是不管用的。集群情况下也要保证写后读。

线程不安全：多个线程同时操作某个数据，出现数据不一致或者被污染的情况。

加锁方式：
synchronized

#### 多线程带来的风险

①线程是抢占式执行的

线程不安全的万恶之源，线程之间的调度完全由内核负责，用户代码中感知不到，也无法控制。线程之间谁先执行，谁后执行，谁执行到哪里从CPU上下来，这样的过程用户无法控制也无法感知到的。

③多个线程尝试修改同一个变量

如果是一个线程修改一个变量，线程安全

如果多个线程读取同一个变量，线程安全

如果多个线程修改不同的变量。线程安全

④内存可见性导致线程安全问题

⑤指令重排序

Java的编译器在编译代码时，会对指令进行优化，调整指令的先后顺序，保证原有的逻辑不变的情况下，提高程序的运行效率


## 线程基础

### 程序、进程和线程

程序是指令和数据的有序集合, 其本身没有任何运行的含义，是一个静态的概念。
进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。
通常在一个进程中可以包含若干个线程， 当然一个进程中至少有一个线程,不然没有存在的意义。线程是CPU调度和执行的的单位。

#### 线程和进程的区别

进程是**程序的一次执行**，是系统进行**资源分配和调度的独立单位**，他的作用是是程序能够**并发执行提高资源利用率和吞吐率**。

由于进程是资源分配和调度的基本单位，因为**进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多**，而线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。

线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。

1.进程是资源分配的最小单位，线程是程序执行的最小单位。

2.进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 。

3.CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多，但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

#### 进程间通信方式有：

1. ==管道( pipe )==
   管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. ==有名管道 (namedpipe)==
   有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. ==信号量(semophore )==
   信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
4. ==消息队列( messagequeue )==
   消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5. ==信号 (sinal )==
   信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
6. ==共享内存(shared memory )==
   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
7. ==套接字(socket )==
   套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

#### 线程间通信方式有：

- 共享内存
- 消息传递
- socket

### 线程使用（实现）方式

有三种使用线程的方法:

- 实现 Runnable 接口（ 不能返回执行结果 ）；
- 实现 Callable 接口（ 能返回执行结果 ）；
- 继承 Thread 类。
- 使用线程池例（如用Executor框架）

#### Runnable和Callable区别

- 区别1: 两者最大的区别，实现Callable接口的任务线程能返回执行结果，而实现Runnable接口的任务线程不能返回执行结果

注意点：Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞线程直到获取“将来”的结果，当不调用此方法时，主线程不会阻塞

- 区别2:Callable接口实现类中run()方法允许将异常向上抛出，也可以直接在内部处理(try...catch); 而Runnable接口实现类中run()方法的异常必须在内部处理掉，不能向上抛出

#### 实现接口 VS 继承 Thread

实现接口会更好一些，因为:

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

### 线程状态转换（六种）

![Java 线程的状态 ](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

![img](file:///C:\Users\qing  chun\Documents\Tencent Files\2017294251\Image\Group2\QQ\UY\QQUYBM310GPC4UJKBQ8}2UY.png)

线程创建之后它将处于 **NEW（初始）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。

当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 **TIMED WAITING（超时等待）**状态。当超时时间到达后 Java 线程将会返回到 **RUNNABLE（运行）**状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的` run() `方法之后将会进入到 **TERMINATED（终止）** 状态。

线程执行 `wait()`方法之后线程进入Waiting状态，由于调用wait()时会释放占用的cpu资源和锁，所以当Waiting线程被其他线程调用Object.notify()唤醒之后，需要重新获取对象上的锁。这时候也会先进入Blocked状态等待获取锁。

#### sleep 和 wait 有什么区别？

- wait 必须搭配 synchronize 一起使用，而 sleep 不需要；
- 进入 wait 状态的线程能够被 notify 和 notifyAll 线程唤醒，而 sleep 状态的线程不能被 notify 方法唤醒；
- wait 通常有条件地执行，线程会一直处于 wait 状态，直到某个条件变为真，但是 sleep 仅仅让你的线程进入睡眠状态；
- wait 方法会释放对象锁，但 sleep 方法不会。
- 在调用 wait 方法之后，线程会变为 WATING（等待）状态，而调用 sleep 方法之后，线程会变为 TIMED_WAITING（超时等待）状态。

#### 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，**会把 run 方法当成一个 main 线程下的普通方法去执行*，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**

## ThreadLocal

ThreadLocal的==作用==就是：线程安全。

ThreadLocal的==本质==就是一个内部的静态的map，key是当前线程的句柄，value是需要保持的值。

由于是内部静态map，不提供遍历和查询的接口，每个线程只能获取自己线程的value。

Threadlocal是thread的一个字段.ThreadlocalMap Threadlocals = 一个threadlocalmap对象
threadlocalmap里面存的是（threadlocal，value）键值对

==流程：==

- 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。
- 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。
- 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。

### 使用场景：

Spring处理线程并发问题用ThreadLocal；

如存储用户Session；

为了解决多线程中**相同变量的访问冲突问题**。同步机制采用了“**时间换空间**”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队；

#### ThreadLocal内存泄漏分析与解决方案

**ThreadLocal造成内存泄漏的原因?**
ThreadLocalMap中使用的key为ThreadLocal的弱引用,而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap中就会出现key为null的Entry。假如我们不做任何措施的话,value永远无法被GC回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用set()、 get()、remove()方法的时候，会清理掉key为null的记录。使用完ThreadLocal方法后最好手动调用remove()方法

**ThreadLocal内存泄漏解决方案?**
每次使用完ThreadLocal，都调用它的remove()方法，清除数据。
在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁—样，用完就清理。

### 结合自己项目

线程池里的核心线程是不会被回收的，threadlocal会越来越多，导致频繁full gc最后oom；

![img](file:///C:\Users\qing  chun\Documents\Tencent Files\2017294251\Image\Group2\Y7\LA\Y7LALLYJSSSC}}@_]7C04G5.png)

jmap：**打印出某个**java进程（使用pid）内存内的，所有对象的情况**（如：产生那些对象，及其数量）。可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。

## volatile

#### volatile

volatile是java虚拟机提供的**轻量级**的同步机制

- 保证可见性   将自己的刷新到主内存，其他线程的声明失效JMM
- **不保证原子性**   原子性就是一个操作同时成功或失败，不可分割，i++底层执行了三个操作，最后的写回主内存可能出现覆盖。 解决方法：sync或者JUC下atomic的AtomicInteger（do。while循环+cas），底层通过CAS实现
- 保证顺序性  禁止指令重排序

#### volatile怎么实现禁止指令重排序

**我们先来了解一下happen-before规则**

虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：

1. 单线程每个操作，happen-before于该线程中任意后续操作
2. volatile写happen-before与后续对这个变量的读
3. synchronized解锁happen-before后续对这个锁的加锁
4. final变量的写happen-before于final域对象的读，happen-before后续对final变量的读
5. 传递性规则，A先于B，B先于C，那么A一定先于C发生

**内存屏障**
内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。
编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。使用volatile关键字就会插入一个内存屏障

**内存屏障**另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。这是不是就是所谓的可见性～

因为内存屏障可以使一些指令按照特定顺序执行。
volatile禁止指令重排序的**规则**：
　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序
　2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序
　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序

#### 你在哪些地方用到过volatile？

- 单例模式DCL代码 ，必须加volatile禁止指令重排，new对象的时候底层编译会有三个步骤，有可能进行指令重排
- CAS底层源码

实例化一个对象其实可以分为三个步骤：

- 分配内存空间。
- 初始化对象。
- 将内存空间的地址赋值给对应的引用。

但是由于操作系统可以`对指令进行重排序`，所以上面的过程也可能会变成如下过程：

- 分配内存空间。
- 将内存空间的地址赋值给对应的引用。
- 初始化对象

如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。

## synchronized

synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。然后在 Java 6 之后 Java 官方从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。

JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

### 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗

**synchronized关键字最主要的三种使用方式：**

- **修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
- **修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。
- **修饰代码块:** 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

**总结：** synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

### synchronized 关键字的底层原理

**① synchronized 同步语句块的情况**

**synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor 的持有权。（monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因）当锁计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

**② synchronized 修饰方法的的情况**

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### synchronized和volatile的区别

 synchronized关键字和volatile关键字比较

- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。但是**volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块**。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。
- **多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞**
- **volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。**
- **volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。**

### synchronized和lock的区别

- synchronized是关键字，lock是接口
- synchronized可以锁代码块和方法，lock只能锁代码块
- synchronized不可得知是否拿到锁，lock可以得知是否拿到锁
- synchronized是不可中断的，lock既可以中断也可以不中断synchronized会自动释放锁，lock只能手动释放锁
- synchronized是非公平锁，lock既可以是非公平锁又可以是公平锁
- lock有一个读写锁，可以提高效率

### synchronized和ReentrantLock的区别

==相同点==:两者都是可重入锁
两者都是可重入锁。"可重入锁"概念是:自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此
时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为O时才能释放锁。
主要==区别==如下:

- ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作;
- ReentrantLock 必须手动获取与释放锁，而synchronized不需要手动释放和开启锁;
- ReentrantLock 只适用于代码块锁，而synchronized可以修饰类、方法等。
- 二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word

### sync锁升级

底层采用CAS来保证原子性，自旋锁获取锁的时候不会阻塞，而是通过不断的while循环的方式尝试获取锁。**优点：减少线程上下文切换的消耗，缺点是会消耗CPU。如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。**

#### 偏向锁、轻量级锁、重量级锁

这三种锁是指锁的状态，并且是针对Synchronized，在java通过引入锁升级的机制来实现高效的synchronized。锁的状态是通过对象监视器在对象头中的字段来表明的。

**偏向锁：**指一段同步代码一直被同一个线程s所访问，那么该线程会自动的获取锁。降低获取锁的代价。

**轻量级锁：**当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，           不会阻塞，提高性能。

**重量级锁：**当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没获取到锁就会进入阻塞，该锁膨胀为重量级锁。重量级会让其他申请线程阻塞，性能降低。 

**偏向锁，轻量级锁都是乐观锁，重量级锁是悲观锁。**
一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是==可偏向的==，意味着，它现在认为只可能有一个线程来访问它，所以==当第一个线程来访问它的时候，它会偏向这个线程==，此时，对象持有偏向锁。偏向第一个线程，这个线程在==修改对象头==成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。
一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，==如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁==，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。
轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是==当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁==，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

## 线程池

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。

### 为什么要用线程池？

1.可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

2.可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

> **池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。**

这里借用《Java 并发编程的艺术》提到的来说一下**使用线程池的好处**：

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

![图解线程池实现原理](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/图解线程池实现原理.png)

### Executor 框架

#### 简介

Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。

> 补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。

#### Executor 框架结构(主要由三大部分组成)

##### 1) 任务(`Runnable` /`Callable`)

执行任务需要实现的 **`Runnable` 接口** 或 **`Callable`接口**。**`Runnable` 接口**或 **`Callable` 接口** 实现类都可以被 **`ThreadPoolExecutor`** 或 **`ScheduledThreadPoolExecutor`** 执行。

##### 2) 任务的执行(`Executor`)

如下图所示，包括任务执行机制的核心接口 **`Executor`** ，以及继承自 `Executor` 接口的 **`ExecutorService` 接口。`ThreadPoolExecutor`** 和 **`ScheduledThreadPoolExecutor`** 这两个关键类实现了 **ExecutorService 接口**。

**这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 `ThreadPoolExecutor` 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。**

> **注意：** 通过查看 `ScheduledThreadPoolExecutor` 源代码我们发现 `ScheduledThreadPoolExecutor` 实际上是继承了 `ThreadPoolExecutor` 并实现了 ScheduledExecutorService ，而 `ScheduledExecutorService` 又实现了 `ExecutorService`，正如我们下面给出的类关系图显示的一样。

**`ThreadPoolExecutor` 类描述:**

```java
//AbstractExecutorService实现了ExecutorService接口
public class ThreadPoolExecutor extends AbstractExecutorService
```

**`ScheduledThreadPoolExecutor` 类描述:**

```java
//ScheduledExecutorService实现了ExecutorService接口
public class ScheduledThreadPoolExecutor
        extends ThreadPoolExecutor
        implements ScheduledExecutorService
```

![任务的执行相关接口](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/任务的执行相关接口.png)

##### 3) 异步计算的结果(`Future`)

**`Future`** 接口以及 `Future` 接口的实现类 **`FutureTask`** 类都可以代表异步计算的结果。

当我们把 **`Runnable`接口** 或 **`Callable` 接口** 的实现类提交给 **`ThreadPoolExecutor`** 或 **`ScheduledThreadPoolExecutor`** 执行。（调用 `submit()` 方法时会返回一个 **`FutureTask`** 对象）

#### 2.3 Executor 框架的使用示意图

![Executor 框架的使用示意图](https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw?x-oss-process=image/format,png)

1. **主线程首先要创建实现 `Runnable` 或者 `Callable` 接口的任务对象。**
2. **把创建完成的实现 `Runnable`/`Callable`接口的 对象直接交给 `ExecutorService` 执行**: `ExecutorService.execute（Runnable command）`）或者也可以把 `Runnable` 对象或`Callable` 对象提交给 `ExecutorService` 执行（`ExecutorService.submit（Runnable task）`或 `ExecutorService.submit（Callable <T> task）`）。
3. **如果执行 `ExecutorService.submit（…）`，`ExecutorService` 将返回一个实现`Future`接口的对象**（我们刚刚也提到过了执行 `execute()`方法和 `submit()`方法的区别，`submit()`会返回一个 `FutureTask 对象）。由于 FutureTask` 实现了 `Runnable`，我们也可以创建 `FutureTask`，然后直接交给 `ExecutorService` 执行。
4. **最后，主线程可以执行 `FutureTask.get()`方法来等待任务执行完成。主线程也可以执行 `FutureTask.cancel（boolean mayInterruptIfRunning）`来取消此任务的执行。**

### 创建线程池的方式

**Executors**			**ThreadPoolExecutor**

使用ThreadPoolExecutor创建线程的话，更能了解线程池运行的规则，避免资源耗尽的风险

- newFixedThreadPool固定线程池
- newSingleThreadExecutor一个线程的线程池
- newCachedThreadPool缓存线程池
- newScedulePool创建一个定长线程池，支持定时及周期性任务执行。

#### 四个基本组成部分

**线程池管理器（ThreadPool）：**用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
**工作线程（PoolWorker）：**线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
**任务接口（Task）：**每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
**任务队列（taskQueue）：**用于存放没有处理的任务。提供一种缓冲机制。

#### 常用的阻塞队列

LinkedBlockingQueue ：容量为 Integer.MAX_VALUE ，可以认为是无界队列。

SynchronousQueue  ：CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务。

DelayedWorkQueue ：按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，也是无界队列。

#### 线程池参数

- **corePoolSize：核心线程数**
      \* 核心线程会一直存活，及时没有任务需要执行
      \* 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
      \* 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭

- **queueCapacity：工作队列**
      \* 当核心线程数达到最大时，新任务会放在队列中排队等待执行 

- **maxPoolSize：最大线程数**
      \* 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
      \* 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常 

- **keepAliveTime：线程空闲时间**
      \* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
      \* 如果allowCoreThreadTimeout=true，则会直到线程数量=0 

- **threadFactory 线程工厂**

- **allowCoreThreadTimeout： **是否允许核心线程空闲退出，默认值为false。 

- **handler：拒绝策略**

  四种拒绝策略

  1. AbortPolicy（默认）：丢弃任务并抛运行时异常（RejectedExecutionException）。 
  2. DiscardPolicy：丢弃任务，但是不抛出异常。
  3. DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 
  4. CallerRunsPolicy：由提交任务的线程处理该任务 

    两种情况会拒绝处理任务：

    - 当线程数已经达到maxPoolSize，并且队列已满，会拒绝新任务

    - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务

      \* ThreadPoolExecutor类有几个内部实现类来处理这类情况：
        \- AbortPolicy 丢弃任务，抛运行时异常
        \- CallerRunsPolicy 执行任务
        \- DiscardPolicy 忽视，什么都不会发生
        \- DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
      \* 实现RejectedExecutionHandler接口，可自定义处理器 

线程池的重点，并不是 `ThreadPoolExecutor`怎么用或者是`Executors`怎么用，**而是在合适的场景下使用合适的线程池，所谓"合适的线程池"的意思就是，ThreadPoolExecutor 的构造方法传入不同的参数，构造出不同的线程池，以满足使用的需要。**

### 线程池大小设置

看应用是CPU密集型的还是IO密集型的，还是混合型的。

- CPU密集
  CPU密集型的话，一般配置CPU处理器个数+/-1个线程，所谓CPU密集型就是指系统大部分时间是在做程序正常的计算任务，例如数字运算、赋值、分配内存、内存拷贝、循环、查找、排序等，这些处理都需要CPU来完成。
- IO密集
  IO密集型的话，是指系统大部分时间在跟I/O交互，而这个时间线程不会占用CPU来处理，即在这个时间范围内，可以由其他线程来使用CPU，因而可以多配置一些线程。
- 混合型
  混合型的话，是指两者都占有一定的时间。

# java基础

### ArrayList` 和 `LinkedList

\1. **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
\2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
\3. **插入和删除是否受元素位置的影响：** ① **`ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **`LinkedList` 采用链表存储，所以对于`add(E e)`方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置`i`插入和删除元素的话（`(add(int index, E element)`） 时间复杂度近似为`o(n))`因为需要先移动到指定位置再插入。**
\4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
\5. **内存空间占用：** ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。

### 序列化和反序列化

\- *序列化：**对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。**序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件**中。

\- **反序列化：**客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息**，通过反序列化重建对象。**

## java中静态变量和成员变量的区别

1、静态变量。

由static修饰的变量称为静态变量，其实质上就是一个全局变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。

2、成员变量

研究一个事物（类），其有： 属性：外在特征；例如人的身高，体重，（对应class成员变量）
行为：能够做什么；例如人有说话，打球等行为。（成员函数）

3、成员变量和静态变量的区别

1、两个变量的生命周期不同
成员变量随着对象的创建而存在，随着对象被回收而释放。
静态变量随着类的加载而存在，随着类的消失而消失。

2、调用方式不同
成员变量只能被对象调用。
静态变量可以被对象调用，还可以被类名调用。

3、别名不同
成员变量也称为实例变量。
静态变量也称为类变量。

4、数据存储位置不同
成员变量存储在堆内存的对象中，所以也叫对象的特有数据。
静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。

### 基本逻辑运算

1，Boolean(检测相等不相等"==""!=")

2，三目运算（a>b?1:2）

3，逻辑与（&&）

--------------------------------------

4，位运算

& -----按位与操作（两个都1则为1，否则为0）

|  -----按位或操作（两个都0则为0，否则为1）

~  -----按位取反操作 （按位取反，包括符号位）

^   -----按位异或操作  （相同为0，不同为1）

-------------------------------------------------------

5，移位运算（也是位运算的一种，移位运算时间要比普通的乘法运算时间快）

左移运算（<<）-------从右往左推，右边补零，这个数*2的几次方

右移运算（>>）--------这个数/2的几次方，在c,c++中，可以代表除运算，在java当中，并不能真正代表除运算，左边空出来位用0或者1来填补，正数用0，负数用1

无符号右移（>>>）------- 从左往右移，不管正负，全用0填补

###### 6，判断相等

（1）==：

----对于基本类型，判断的是值是否相同

----对于引用数据类型，判断的是地址是否相同

（2）equals：

-----如果是在object类里边,使用的是==,比较的是地址；

如果是在String类里边，重新定义equals方法，先比较地址，如果地址不相同，然后再比较里边的内容是否相同。

----不支持基本数据类型（基本数据类型在栈里边开辟空间）的调用

7，***\*&与&&的区别\****

按位与：**a&b是把a和b都转换成二进制数然后再进行与的运算；

**逻辑与：**a&&b就是当且仅当两个操作数均为 true时，其结果才为 true，只要有一个为false，a&&b就为false。

8，||与|的区别


1，&&和||是短路运算符，&和|是非短路运算符。

2，&&与&区别：两者都表示“与”运算，但是&&运算符第一个表达式不成立的话，后面的表达式不运算，直接返回。而&对所有表达式都得判断。

3，|| 与|区别：两者都表示“或”运算，但是||运算符第一个表达式成立的话，后面的表达式不运算，直接返回。而|对所有表达式都得判断。

### 关于八大基本类型

**类型的转换**

![img](https://img-blog.csdnimg.cn/20190314165054201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1eHVlX2phdmE=,size_16,color_FFFFFF,t_70)  

**转换规则**：从存储范围大的类型到存储范围小的类型。

**具体规则为**：double→float→long→int→short(char)→byte

### java数组中最多可以放多少个元素？

java数组用int做引索，最大容量2G=2 147 483 639=2^31^个元素空间。
同时受“可用内存空间”的大小限制。
java每个对象元素实际占用内存都大于12字节，即使你有16GB内存，也不够2G个对象。

### String，StringBuffer，StringBuilder

String是不可变的，而StringBuffer,StringBuilder是可变的；

String中的对象是不可变的，也就可以理解为常量，线程安全。

StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

StringBuffer是线程安全的，StringBuilder是非线程安全的，所以性能上优于StringBuffer。
造成这样的原因是StringBuffer在执行方法的时候都要求同步，所以它是安全的；StringBuilder对象在执行方法时则没有synchronized去要求它是同步的，所以它是非线程安全的。

操作少量的数据:适用String

单线程操作字符串缓冲区下操作大量数据:适用StringBuilder

多线程操作字符串缓冲区下操作大量数据:适用StringBuffer

### String为什么要设立成不可变类

1.由于 String 在 Java 中是不可变的，这样 Java Runtime 就可以**节省大量的 Java 堆空间**，因为不同的 String 变量可以在String Pool中引用相同的 String 变量(实际String对象的值)。
2.如果String不是不可变的，那么它**将对应用程序造成严重的安全威胁。** 例如，数据库用户名，密码作为String传递以获取数据库连接.如果String是可变的,黑客可以轻松改变它的引用值以导致应用程序中出现安全问题。
3.由于String是不可变的,所以它在**多线程环境(multithreading)是线程安全的,**一个 String 实例可以在不同的线程中共享。 这避免了使用同步(synchronization)来保护线程安全,String是隐式线程安全的.
4.String被用在了classloader 类加载器中，**不可变性提供了正确的类由Classloader加载的安全性。** 例如，假设您尝试加载java.sql.Connection类的实例，但引用的值更改为myhacked.Connection类，可以对数据库执行有害的操作。
5.由于 String 是不可变的，它的 hashcode 在创建时就被缓存了，它不需要再次计算,并且它的**处理速度**比其他 Object对象要快。这也是为什么 HashMap 常用 String 对象作 key的原因

### 字符串为什么是不可变的，以及不可变的好处

- 类本身是final修饰的
- 数组也是final修饰的，private修饰的
- 整个类没有提供任何一个修改数组内容，以及返回数组引用的方法

### String中的方法

![image-20220518224153939](C:\Users\qing  chun\AppData\Roaming\Typora\typora-user-images\image-20220518224153939.png)

![image-20220518224209435](C:\Users\qing  chun\AppData\Roaming\Typora\typora-user-images\image-20220518224209435.png)

### Java创建对象的几种方式

- 调用构造函数

  - 使用new关键字

  - 使用Class类的newInstance方法（无参，反射）

    ```java
    Employee emp2 = (Employee)Class.forName("org.programming.mitra.exercises.Employee").newInstance();
    
    或者Employee emp2 = Employee.class.newInstance();
    ```

    

  - 使用Constructor类的newInstance方法(有参无参均可，反射)

    ```java
    Constructor constructor = Employee.class.getConstructor();
    
    Employee emp3 = constructor.newInstance();
    ```

    

- 不调用构造函数

  - 使用clone方法
  - 使用反序列化：当我们序列化和反序列化一个对象时，jvm会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口

- 除了第1个方法，其他4个方法全都转变为invokevirtual(创建对象的直接方法)，第一个方法转变为两个调用，new和invokespecial(构造函数调用)。

### JDK和JRE

JDK拥有JRE所拥有的一切，还有编译器(javac) 和工具(如javadoc和jdb)。它能够创建和编译程序。
JRE是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机(JVM)，Java 类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。

### Java泛型了解么？什么是类型擦除？介绍⼀下常用的通配符

Java泛型(generics) 是JDK5中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。

### ==和equals区别

==：它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。
(基本数据类型比较的是值，引用数据类型比较的是内存地址)

equals()：它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。equals()方法在0bject类中，相当于==，在字符串中是比较字面值是否相等，而0bject类是所有类的直接或间接父类。

### Object常见方法

>  如图可知，Object类有12个成员方法，按照用途可以分为以下几种 
>  1，构造函数 
>  2，hashCode和equale函数用来判断对象是否相同, 比较的是对象的地址
>  3，wait(),wait(long),wait(long,int),notify(),notifyAll() 
>  4，toString()和getClass, 
>  5，clone() 
>  6，finalize()用于在垃圾回收 

### HashCode()和equals()

#### HashCode()介绍

hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的0bject类中，这就意味着Java中的任何类都包含有hashCode()函数。另外需要注意的是:
0bject的hashcode方法是本地方法，也就是用C语言或C++实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

#### 为什么重写equals()要重写hashcode()

对于对象集合的判重，如果一个集合含有100个对象实例，仅仅使用equals()方法的话，那么对于一个对象判重就需要比较4950次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的hashCode不相同，也不再需要调用equals（）方法，从而大大减少了equals()比较次数。所以从程序实现原理上来讲的话，既需要equals()方法，也需要hashCode()方法。那么既然重写了equals（），那么也要重写hashCode()方法，以保证两者之间的配合关系。



### 访问修饰符

定义: Java中,可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持4种不同的访问权限。

- private:在同一类内可见。使用对象:变量、方法。注意:不能修饰类（外部类）
- default (即缺省,什么也不写,不使用任何关键字）：在同一包内可见,不使用任何修饰符。使用对象:类、接口、变量、方法。
- protected：对同- -包内的类和所有子类可见。使用对象:变量、方法。注意:不能修饰类（外部类）。
- public：对所有类可见。使用对象：类、接口、变量、方法
  ![image-20210804154317989](https://gitee.com/shen1shen1/pic-md1/raw/master/image-20210804154317989.png)

### this关键字

-----永远代表当前对象；

1，this属性名

———一个方法当中，当全局变量和局部变量重名的时候，this关键字用来区分全局变量和局部变量；

2，this方法名

———让类中一个方法调用类当中另外一个方法；（static->值是当前类；this->值是当前对象）；

3，this()

———this访问本类的构造器；

（1）不能在普通方法中使用，只能在构造方法中使用；普通方法不能调用构造方法，因为对象是调用普通方法的主体，没人指向；

（2）this()在构造方法中只能是第一条语句，因为要先构造，后赋值；

（3）在一个类下的两个构造器当中不能通过this()互相调用，互相调来调去，形成死循环，没有意义；

（4）不能和super()互相使用,因为super()调用的是父类的关键字，不是当前类的，会冲突；

### static关键字

![image-20210707110156941](C:\Users\qing  chun\AppData\Roaming\Typora\typora-user-images\image-20210707110156941.png)



(1)  static就是方便在没有创建对象的时候对方法和变量进行调用；

(2)  static的内存使用情况----()

(3)   static修饰符   

​       -----static修饰变量 （static修饰的变量属于类变量，被所有对象共享）(面试重点)

​       ------static修饰方法（1，this关键字不能在static方法当中使用；2，静态方法中不能使用非静态的方法，非静态方法能使用静态的方法；）

​       ------static修饰代码块（static修饰的代码块，在main方法之前执行，以便优化程序）

###### 输出顺序（面试重点）

我是静态块P
我是静态块K

**（1,静态块只执行一次初始化，后边就不再执行）**

**（2,所有静态块，静态属性的执行只能由当前类的第一个对象触发执行）**

我是非静态块R
我是非静态块U

（属性和非静态块是同等级别的，谁排在上边谁先输出；）

我是构造方法w

classloder -> 类加载器

第一步：找main方法

main方法在哪就加载哪个类（加载的顺序不是运行的顺序）

第二步：mian方法所在的类的static先运行

第三步：加载时先加载父类，找父类

### final、finally、finalize

**final关键字主要用在三个地方：变量、方法、类。**

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

**fianlly**
finally在异常处理时，提供finally块来执行任何清除操作。如果发生异常，匹配的catch块就会执行，然后进入finally块执行。

**finalize**
finalize是方法名，java.lang.Object里定义的，也就是说每个对象都有这一个方法。
垃圾回收器删除对象之前调用对象的该方法做清理工作。

### Java特性（封装继承多态）

**封装**

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

**继承**

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

**多态**

多态的三个条件：

1.子类需要继承父类

2.子类必须重写父类的相关方法

3.向上转型：父类的引用指向子类的对象

同一行为具有不同的表现形式或形态的能力叫做多态

子类对象调用重写的方法时，默认调用的是子类的方法

多态的作用：

为了丰富父类的功能(继承：丰富子类的功能)

继承后子类可以调用父类的一些方法，父类不能调用子类的方法

父类对象指向子类对象，

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

### 重载和重写

- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性,而后者实现的是运行时的多态性。
- **重载**：发生在同一个类中，**方法名相同参数列表不同**（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分
- **重写**：发生在有继承关系的类中，**方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类**（里氏代换原则）；**如果父类方法访问修饰符为private则子类中就不是重写**。
- **构造方法**不能被继承，因此**不能被重写**，但**可以被重载**。

### 方法的覆盖

方法的覆盖必须发生在继承当中，指子类重写父类的同名方法。方法的重载是在一个类中出现多个同名参数不同的方法
【方法覆盖的原则】1.子类方法的名字和参数必须和父类保持一致2.子类方法的修饰符必须的范围必须大于等于父类同名方法的修饰符 public>private>无修饰符，否则会报错

### 深拷贝VS浅拷贝

浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
深拷贝：对基本数据类型进行值传递，对引用数据类型，创建-一个新的对象，并复制其内容，此为深拷贝。

浅拷贝只是拷贝了原对象的地址，所以原对象的任何值发生改变的时候，拷贝对象的值也会随之而发生变化。
深拷贝则是拷贝了源对象的所有值而不是地址，所以即使源对象的值发上变化时，拷贝对象的值也不会发生变化。

简单地说，深拷贝对引用数据类型的成员变量的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间

### 请简述Integer类型的128陷阱

在Integer的ValueOf()方法中，Integer类型的数据在-128-127范围内的数是存储在一个数组中的，直接返回该值在内存中的地址
超出这个范围的话，会在堆中开辟新的内存空间，地址不同
当数值在[-128,127 ]之间时，在常量池中指的是同一对象,所以"=="的结果为true .而不在这一范围内时，则创建两个不同的对象,自然"=="的结果为false

### 抽象类和接口

![image-20210825123045986](https://gitee.com/shen1shen1/pic-md1/raw/master/img/20210825123047.png)

1. 接口的方法默认是public,所有方法在接口中不能有实现(Java 8开始接口方法可
   以有默认实现) ，而抽象类可以有非抽象的方法。
2. 接口中除了static、final 变量,不能有其他变量，而抽象类中则不一-定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过
   extends关键字扩展多个接口。
4. 接口方法默认修饰符是public,抽象方法可以有public、protected 和default这
   些修饰符( 抽象方法就是为了被重写所以不能使用private关键字修饰! )。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，
   是一种行为的规范。

接口(interface)和抽象类(abstract class)是支持抽象类定义的两种机制。

接口是公开的，不能有私有的方法或变量，接口中的所有方法都`没有方法体`，通过关键字`interface`实现。

抽象类是可以有私有方法或私有变量的，通过把类或者类中的方法声明为`abstract`来表示一个类是抽象类，被声明为抽象的方法`不能包含方法体`。子类实现方法必须含有相同的或者更低的访问级别(public->protected->private)。抽象类的子类为父类中`所有抽象方法`的具体实现，否则也是抽象类。

接口可以被看作是抽象类的变体，接口中所有的方法都是抽象的，可以通过接口来间接的实现`多重继承`。接口中的成员变量都是`static final`类型，由于抽象类可以包含部分方法的实现，所以，在一些场合下`抽象类比接口更有优势`。

**`相同点`：**
（1）都**不能**被实例化
（2）接口的实现类或抽象类的子类都只有**实现了接口或抽象类中的方法后**才能实例化。

**`不同点`：**
（1）接口只有定义，**不能有方法的实现**，`java 1.8中可以定义default方法体`，而抽象类可以有定义与实现，方法可在抽象类中实现。
（2）实现接口的关键字为`implements`，继承抽象类的关键字为`extends`。一个类**可以实现多个接口**，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
（3）接口强调特定功能的实现，而抽象类强调所属关系。
（4）接口成员变量默认为`public static final`，**必须赋初值**，不能被修改；其所有的成员方法都是`public`、`abstract`的。抽象类中成员变量默认`default`，可在子类中被重新定义，也可被重新赋值；抽象方法被`abstract`修饰，不能被`private`、`static`、`synchronized`和`native`等修饰，**必须以分号结尾**，**不带花括号**。
（5）接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。

### 自动拆装箱

基本数据类型转化成包装类对象-----》自动完成：自动装箱

包装类对象转化成基本数据类型-----》自动拆箱

#### 为啥是自动的？

编译器行为

#### 为什么要有包装

1，面向对象

2，集合

### 消息队列

https://www.jianshu.com/p/ffd0806e0947

## 异常体系

![image-20210808162104720](https://gitee.com/shen1shen1/pic-md1/raw/master/image-20210808162104720.png)

- 所有的异常都是由 **Throwable** 继承而来，但在下一层立即分解为两个分支：**Error** 和 **Exception**

- **Error** 类层次结构描述了 **Java** 运行时系统的内部错误和资源耗尽错误。(栈溢出等)

- Exception:一个分支派生于 **RuntimeException** ; 另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于 **RuntimeException** ; 而程序本身没有问题， 但由于像 **I**/**O** 错误这类问题导致的异常属于其他异常

- **RuntimeException** ：（程序问题） 

  错误的类型转换。 

  数组访问越界 

  访问 **null** 指针

- **IOException**： 

  试图在文件尾部后面读取数据。 

  试图打开一个不存在的文件。 

  试图根据给定的字符串查找 **Class** 对象， 而这个字符串表示的类并不存在

- 受查异常：IOException；非受查异常：RuntimeException，error

## 反射和代理

### 反射

**一，反射是什么（反射是框架设计的灵魂）**

1，JAVA反射机制是在***\*运行状态中\****

对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能够调用它的任意一个方法和属性；

这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

**2，反射提供的功能：**

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时调用任意一个对象的方法

（要想解剖一个类,必须先要获取到该类的字节码文件对象（class）。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.）

**1、获得Class：主要有三种方法：**

（1）Object-->getClass

（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性

（3）通过class类的静态方法：forName(String className)（最常用），获取到类的信息，通过method.invoke执行方法

三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。

 **谈谈反射机制的优缺点**

**优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利

**缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

### 代理

代理模式是一种比较好理解的设计模式。简单来说就是 **我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**

举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子

#### **静态代理**

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类\)。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， **静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

静态代理实现步骤:

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类。

**静态代理总结:**

优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。

缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。 

如何解决静态代理中的缺点呢?答案是可以使用动态代理方式

#### **动态代理**

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( **CGLIB 动态代理机制**)。

**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。

**动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。**

**JDK 动态代理类使用步骤**

1. 定义一个接口及其实现类；
2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)` 方法创建代理对象；

**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**

**为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**

**CGLIB 动态代理类使用步骤**

1. 定义一个类；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 通过 `Enhancer` 类的 `create()`创建代理类；

 **JDK 动态代理和 CGLIB 动态代理对比**

1. **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。
3. CGLIB基于继承来实现代理，代理对象实际上是目标对象的子类，它内部通过第三方类库ASM，加载目标对象类的class文件，修改字节码来生成子类，生成类的过程较低效，但生成类以后的执行很高效，可以通过将ASM生成的类进行缓存来解决生成类过程低效的问题；

**静态代理和动态代理的区别**

1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

**动态代理有以下特点:**
1.代理对象,不需要实现接口
2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)

## 内部类

#### 成员内部类

 成员内部类是最普通的内部类，它的定义为位于另一个类的内部 

```java
class Circle {
	double radius = 0;
  	public Circle(double radius) {
    	this.radius = radius;
    }
    class Draw {     //内部类
		public void drawSahpe() {
        	System.out.println("drawshape");
        }
    }
}
```

#### 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 

```java
class People{
	public People() {
    
	}
}
```

```java
class Man{
	public Man(){
    
	}
  
	public People getWoman(){
    	class Woman extends People{  //局部内部类
      	int age =0;
    	}
    return new Woman();
	}
}
```

#### 匿名内部类

匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。 



#### 静态内部类

静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 

```java
public` `class` `Test {
  ``public` `static` `void` `main(String[] args) {
    ``Outter.Inner inner = ``new` `Outter.Inner();
  ``}
}
```

```java
class` `Outter {
  ``public` `Outter() {
    
  ``}
  
    static` `class` `Inner {
    ``public` `Inner() {
      
    ``}
  ``}
}
```

为什么在Java中需要内部类？总结一下主要有以下四点：

　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，

　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。

　　3.方便编写事件驱动程序

　　4.方便编写线程代码

## I/O通信



### BIO（Blocking I/O）

**同步阻塞I/O模式**，数据的读取写入必须阻塞在一个线程内等待其完成。

采用 **BIO 通信模型** 的服务端，**通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 `while(true)` 循环中服务端会调用 `accept()` 方法等待接收客户端的连接的方式监听请求，**请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。

如果要让 **BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程**（主要原因是 `socket.accept()`、 `socket.read()`、 `socket.write()` 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 **一请求一应答通信模型** 。



### NIO（New I/O）

NIO是JDK1.4引入的，目的就是为了提高速度

**NIO是一种同步非阻塞的I/O模型**，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。

NIO中的N可以理解为Non-blocking，不单纯是New。**它支持面向缓冲的，基于通道的I/O操作方法。** **NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。**阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；**对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。**



IO流是阻塞的，NIO流是不阻塞的。



**IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。**

在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。

最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。

3)**Channel (通道)**

NIO 通过Channel（通道） 进行读写。

通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。

4)Selectors(选择器)

**NIO有选择器，而IO没有。**

选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。

##### **NIO 读数据和写数据方式**

通常来说NIO中的所有IO都是从 Channel（通道） 开始的。

- 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。
- 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。



### AIO (Asynchronous I/O)

AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,**它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。**

**AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。**对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释

查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

# java数据结构

## 树

`数组`的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任和一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑

`普通链表`由于它的结构特点被证明根本不适合进行查找

`哈希表`是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也适合大规模的查找

`二叉查找树`因为可能退化成链表，同样不适合进行查找

`AVL树`是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦

`红黑树`是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。

`多路查找树` 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。

`B树`与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。

`B+树`在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。

`B*树`是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。

### 二叉树、完全二叉树、满二叉树

- 二叉树: 最多有两棵子树的树被称为二叉树
- 完全二叉树: 如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树
- 满二叉树: 二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上

### 红黑树

红黑树是一棵二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是红色,也可以是黑色；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。

**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）如果一个节点是红色，那么它的两个子节点就是黑色的(没有连续的红节点)**
**（4）对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点。**                                      
**（5)   每个页节点都是黑的                                                                                                                                          **
**（6）所有左节点都<=父节点，所有右节点都>父节点**



### 红黑树和自平衡二叉(查找)树区别

>   1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
>   2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。
>
>   AVL树是最早出现的自平衡二叉(查找)树
>   红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
>   红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。
>
>   红黑树是牺牲了严格的高度平衡的优越条件为代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。
>   此外，由于它的设计，任何不平衡都会在三次旋转之内解决。
>   当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。
>   红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.

### 红黑树与B树的区别

> (B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，**B-tree就是指的B树**。特此说明。)
>
>
> B树又叫平衡多路查找树。B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树。与红黑树很相似，但在降低磁盘I/0操作方面要更好一些。 许多数据库系统都一般使用B树或者B树的各种变形结构，如下文即将要介绍的B+树，B*树来存储信息。
>
> 红黑树与B树的区别在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的 B树的高度也为O（lgn） ，但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以， B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作

### B树、B+树

#### B树

B树(英语: B-tree)是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。

- 根结点至少有两个子女。
- 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
- 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
- 所有的叶子结点都位于同一层。
- 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree:

![img](/_images/alg/alg-tree-15.png)

#### B+树

B+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。

在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。

b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。

将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示:

![img](/_images/alg/alg-tree-16.png)

#### B树、B+树

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

#### 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

####  b+树相比b树的优点 

1. b+树的非叶节点不保存数据，所以可以存储更多节点元素
2. b+树的查找路径是由根到叶子节点，每次查找路径长度比较稳定 
3. 范围遍历，b+树的叶子节点构成一条链表，访问更加方便  

### 跳表

跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见右边的示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。

### 堆和树的区别

**节点的顺序**
在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。

**内存占用**
普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额外内存。堆仅仅使用一个数据来存储数组，且不使用指针。

**平衡**
二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。

**搜索**
在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。

# 消息队列有什么优缺点

优点上面已经说了，就是**在特殊场景下有其对应的好处**，**解耦**、**异步**、**削峰**。

缺点有以下几个：

- **系统可用性降低**
  系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？如何保证消息队列的高可用，可以[点击这里查看](https://zhuanlan.zhihu.com/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md)。

- **系统复杂度提高**

  加入MQ后，还要考虑很多其他的问题，比如：消息有没有重复消费，消息丢失怎么处理，怎么保证消息传递的顺序性，等等

- **一致性问题**
  A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。

所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。



点对点（1V1）的这种形式，消息生产出来之后有且仅有一个消费者把他消费掉。这种场景就类似于Dubbo里面的consumer和provider。当consumer每需要一个服务 调一个服务就会有一个仅且一个provider为他提供服务（对一次服务来讲）。在这种情况下，理论上我们其实可以用MQ来代替Dubbo，但是Dubbo宕机之后还可以继续使用，MQ宕机的话就不能用了。这是一对一的这种形式，在某种程度上来讲点对点是可以解决Dubbo问题的

发布订阅（1VN）的这种形式，类似于QQ空间，你发一个动态，然后所有人都能看到。这一个生产者生产消息之后，N多个消费者都可以订阅到这条消息，各自做各自的处理。

MQ三个特性

削峰 异步 解耦

削峰指的是我们的业务请求，业务逻辑随着请求量的增大，你的业务系统压力会跟着他增大，当我们引入MQ之后，当我们的业务量增大之后，我们把所有的请求只要进MQ就结束了，立即返回，然后会把这个压力变成平稳的。这个削峰的话就像水库一样，跟线程池里的那个工作队列一样。随着我们请求压力的变大，他所有的业务系统压力因为被MQ给吞掉了，把这一堆请求都放到了你的MQ里面，我们的业务系统压力呢是从MQ中读出消息来之后才去做处理的，所以说压力没有那没大了。但是引入MQ之后也会遇到一个问题，当你的请求进入MQ之后，就要给前端页面一个响应了。但是这个响应一般是中间状态，比如买火车票的时候，下单完成后会显示，订单充足，订单正在处理中请稍后。。然后五秒之后，你的系统再次发送请求，然后告诉你请求成功了。或者是由我们的服务器主动推送这条消息给我们的手机端，但是这个时候用的就不是http协议了（websocket、或者自己封装一个协议、等等），因为HTTP协议不能主动给我们推送消息。然后这个就是MQ的削峰和异步。

然后1VN这种模式是真正的把这个东西给解耦掉了。我们很多步骤都是耦合在一起的，比如说，还是买火车票，下完订单之后，给你发短信啊、发邮件啊、发微信啊、发支付宝这些。这些操作按照以往来讲的话，要先邮件、再微信、再短信、再支付宝等等这些流程，假如每个花一秒时间，四个就是四秒。那按道理来讲，他们四个直接都没有关联，所以可以直接通过这个订阅模式来处理，短信订阅这个队列，微信、支付宝、邮箱都订阅这个队列，然后一条写进来，N个都接收了，接收到之后分别去处理自己的业务逻辑，最后去给他做一个日志的统一打印，或者说做一个统计。谁成功了，谁没成功。比如邮件是1，支付宝是2，微信是4，短信是8。然后成功了的话应该是15，要不是15就看少多少，比如少1那就是邮件没成功，少三就是邮件和支付宝没成功，方便快捷。



#### 没有被正确消费的怎么办

生产者不断生产消息，然后放到MQ里，消费者不断从MQ里取消息然后消费。

生产者正常的把消息放到MQ里面，由于种种原因MQ宕机了，再重启的时候里面消息丢了，消费者没收到消息。

生产者生产消息进MQ里面，然后消费者由于自身原因执行着执行着报错了，导致这个消息没有被正常消费，没有达到我们应有的效果，这个时候也可以说消息丢了

生产者正常的把消息放到MQ里面，然后消费者消费了一遍，由于网络原因，我又拿出那条消息，又消费了一遍。

1. 丢了

   最常见的就是在生产者里面留一个备份，当这个消息被确认正确消费之后，然后就可以清除这个备份。有了这个备份之后就不怕消息丢失了，MQ崩了之后还可以从备份里再拿回来。（可以用DB或者Redis，Redis的话可以用一个列表或者哈希来处理他）

   第一，对于每条消息我们要做唯一编号，这个编号在整个系统里边是唯一的，拿到这个唯一编号之后，然后用一个哈希或者什么，什么A机器的某一个消息队列的请求全放到这个哈希里边，key就是这个唯一编号，value就是整条消息。然后当我们这个消息确认被正确消费了，从这个Redis里边根据我们对应的规则找到他对应的消息，给他设置成null，然后再设置成过期。

   通过一个应答机制来保证我是这个消费者，正常被消费的

2. 重复

   可以借助MQ、Redis做幂等性处理，也可以消息本身做处理。比如转账的时候可以写上转帐户100元，转入100元，转账后账户余额200元

当转账成功后

![img](https://img-blog.csdn.net/20170816171523564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb01hdmVyaWNrMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



# 缓存

## 什么时候用缓存

https://blog.csdn.net/superviser3000/article/details/98994780

缓存在互联网架构中是十分重要的一部分，良好设计的缓存可以有效缓解系统压力，提高系统整体性能。
但是，使用缓存也会提高技术复杂度，一般情况下从两个方面来确认是否需要缓存。

1. **CPU占用高的行为**
   某些过程需要消耗大量的cpu资源进行计算，可以根据业务考虑将结果保存缓存。
2. **数据库访问频繁**
   如果系统的访问量十分巨大，全部请求指到数据库中可能会导致连接不够甚至数据库崩溃，那么使用缓存是一种有效的暂时手段。
   注意，这意味着使用缓存可以随意应对高并发数据量，一旦发生缓存雪崩，而后端没有相应的处理方案的话，数据库肯定会陷入超负荷状态。

**缓存加速原理**

数据库访问数据，磁盘IO，慢
缓存里访问数据，内存操作，快
数据库里的热数据，可在缓存冗余一份
先访问缓存，如果命中，能大大的提升访问速度，降低数据库压力

### 使用基本方法 -Cache Aside 模式

1. 先访问缓存，如果命中直接返回结果
2. 如果没命中缓存，去数据库查询结果，返回并保存到缓存中一份记录

如果读没有命中，或者涉及写操作，系统流程将会变得更复杂。

读操作没有命中缓存

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQ5MTExMy1jNmMxYjUxYzhkMTVhZmQzLmpwZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMjcwL2Zvcm1hdC93ZWJw)

image

 

尝试从缓存get数据，结果没有命中
从数据库获取数据，读从库，读写分离
把数据set到缓存，未来能够命中缓存

写操作

写需要修改数据库的值和缓存中的值，那么就会有两种修改方式

1. 先操作数据库，再写缓存
2. 先写缓存，再操作数据库

### 缓存的两种更新方法

- 更新
- 淘汰
  相比于更新，淘汰会多一次cache miss。
  更新操作可能会需要额外的IO操作去查库或者重新计算。
  所以在绝大部分场景下，淘汰比更新需要的性能更小，所以推荐直接淘汰，在下次请求cache miss之后再进行操作放入缓存。

根据上文分析，`操作缓存最好使用先操作数据库再淘汰缓存`是最好的使用方式。

缓存是通过牺牲强一致性来提高性能的。所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短太长都不好，太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。

# DNS

1、什么是DNS

DNS（domain name service）：域名解析服务；

提供的服务：

         正向解析：将我们熟知的域名，解析为地址，方面网络上的通信；
         一个域名可以对应多个ip地址。
    
         逆向解析：将IP地址解析为域名，方便记忆。

软件服务：BIND（berkeley internet name domain）dns软件。

2、DNS域

DNS域名是以倒挂书树的方式存在的，分为：根域名、顶级域名、二级域名、子域、主机名称
3、域名解析的工作原理

<1> 客户机提出域名解析请求,首先查询本机的域名缓存文件（/etc/resolv.conf），若该文件中存在，则直接解析，若该文件中不存在则发送解析请求到本地的域名服务器；

<2> 当本地的域名服务器收到请求后,先查询本地服务器的缓存,如果有该解析,则本地的域名服务器就直接把查询的结果返回；如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器；

<3> 当根域名服务器收到解析请求时，根域名服务器会解析请求的地址，根据域名将其返回给本地域名服务器中含查询域(根的子域)的主域名服务器的地址；

<4> 本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址；

<5> 重复第四步,直到找到正确的纪录；
<6> 本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机。

其中域名的解析过程分为迭代查询和递归查询，递归查询：在本地之间的解析往往是递归查询，迭代查询：在dns服务器之间的查询为迭代查询。其中递归的查询只需要发送一条命令即可；迭代查询需要不断由查询主机发送命令去查询。同时递归查询可以得到准确的结果而，迭代查询只能得到一个参考是值，但递归查询是比较消耗资源的。

# RPC

## RPC简介

### RFC

RFC(Request For Comments) 是由互联网工程任务组(IETF)发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前RFC文件由互联网协会(Internet Society，ISOC)赞助发行。

RPC就收集到了rfc 1831中。可以通过下面网址查看：

https://datatracker.ietf.org/doc/rfc1831/

### RPC

RPC在rfc 1831中收录 ，RPC（Remote Procedure Call） 远程过程调用协议

![img](https://gitee.com/shen1shen1/pic-md1/raw/master/1650186381617wps1.jpg) 

RPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。

RPC是**上层协议**，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上讲只要是满足网络中进行通讯调用都统称为RPC，甚至HTTP协议都可以说是RPC的具体实现，但是具体分析看来RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。

RPC协议是基于分布式架构而出现的，所以RPC在分布式项目中有着得天独厚的优势。

### RPC和HTTP对比

- **具体实现：**
  - RPC可以基于TCP协议，也可以基于HTTP协议
  - HTTP基于HTTP协议
- **效率：**
  - RPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。
  - HTTP：如果是HTTP 1.1 报文中很多内容都是无用的。如果是HTTP2.0以后和RPC相差不大，比RPC少的可能就是一些服务治理等功能。
- **连接方式：**
  - RPC：支持长连接。
  - HTTP：每次连接都是3次握手。（断开链接为4次挥手）
- **性能:**
  - RPC可以基于很多序列化方式。如：thrift
  - HTTP 主要是通过JSON，序列化和反序列效率更低。
- **注册中心:**
  - RPC:一般RPC框架都带有注册信息
  - HTTP：都是直连
- **负载均衡:**
  - RPC：绝大多熟RPC框架都带有负载均衡策略
  - HTTP：一般都需要借助第三方工具，如nginx
- **综合结论:RPC框架一般带有丰富的服务治理功能，更适合企业内部接口调用。而HTTP更适合多平台之间相互调用**

## 什么是RPC

- RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务
- 本地过程调用：如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。
- 远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？

1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。
2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。
   3.数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。

## 手写RPC框架

### HTTPClient实现RPC

### RMI实现RPC

### RMI+Zookeeper自定义框架

单例模式：获取远程调用的对象，服务注册

开闭原则：面向扩展开放，面向修改关闭，这意味着一个实体是允许不改变他的源代码的前提下变更他的行为

反射：

观察者模式：watcher机制涉及状态的监听，而这一状态其实包含了两种状态：客户端与服务器之间的连接状态（通知状态）以及节点的状态（事件类型）

# Dubbo

### Dubbo是什么

Dubbo是阿里巴巴开源的基于JAVA的高性能RPC分布式服务框架，现已成为Apache基金会孵化项目。

### 为什么要用Dubbo

内部使用了 Netty、Zookeeper，保证了==高性能高可用性==。使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。

### Dubbo的基本结构：

- 提供者Provider：向注册中心注册服务，暴露服务提供的一方；
- 服务消费者Comsumer:向注册中心注册服务，并获取服务提供列表来使用，服务消费的一方；
- 注册中心Register:服务注册与发现的注册中心；
- 服务监控中心Monitor:统计服务调用次数和调用时间的监控中心；
- 服务容器Container：服务运行容器。

详细查看Dubbo篇：[Dubbo基本原理介绍](https://mp.weixin.qq.com/s?__biz=MzUzOTk5MzYyNg==&mid=2247483891&idx=1&sn=09fb28190ca061c96358ff693345e4f6&chksm=fb3eb286cc493b9021fba07f973ebe13e9122be7fe8219aafdb21ecb4b82676973f4481e1b60&token=230166154&lang=zh_CN#rd)

### Dubbo能做什么

- 透明化的远程方法调用
  -  就像调用本地方法一样调用远程方法
  -  只需简单配置，没有任何API侵入
  -  软负载均衡及容错机制
     -  可在内网代替F5等硬件负载均衡器
  -  服务自动注册与发现
     -  不在需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并可以平滑添加或删除服务提供者。

### 微服务的组成模块

微服务存在的原因：节约成本

Spring cloud:功能多传输慢，dubbo功能少，传输快

微服务模块：

1. **生产者**：对其他人有用的模块，自己用，其他人也有可能用。例如生成二维码，短信发送，文件上传。本质是tomcat+springboot，解析的是自定义协议，不是http协议，和调用controller相同
2. **消费者**：调用方是消费者，类比京东，我就是消费者，原理和MyBatis相同，是AOP
3. **中央管理平台**：JSF管理平台的接口，注册接口，**核心功能是**：记录消费者，生产者，生产者上线主动通知中央管理平台
4. **服务发现，服务治理**：JSF管理平台点进去接口对应的机器统计。管理消费者，生产者有哪些，
5. **传输协议**：dubbo传输快的原因，为了内部传输快，需要自定义协议，减少协议中的一些冗余
6. **传输序列化反序列化**：过程非常慢，毫秒级开销。对象转成字符串，在由字符串重组为对象，原理是反射，性能慢，因为要遍历（内存里的）方法区，（属性，构造方法），检查有没有注解。**优化：**1.去反射，用新的结构代替,例如protobuffer。2.启动时反射可以避免发送数据时反射。可以编译生成一个类能把需要发的类和对象名字，值都发过去，启动的时候调用这个类。通过伴生类。把所有数据类型转成一个byte数组，数据长度通过一个启动时注解确定。
7. **流量控制**：限制消费者调用量，每分钟多少次，消费者自己限制自己，消费者引用的时候会有一个消费者j a r包，一旦超出自己的最大调用，不发送，并且报警，重新申请。**限流算法：**一分钟内多台服务器一共不超过某个调用量。      每个消费者内部有nginx,通过负载均衡确定访问到哪一台机器。
8. **权限控制**：申请之后才能调用。如果没有这一层，生产者崩溃无法找到原因。由消费者自己拦截。

# 补课内容

1，操作系统分配空间的时候一个变量至少要分配一个页。

2，网络传输通过网线传输，发送的数据包实际是byte数组。byte数组是由网卡驱动发送或接收的。

数据包的协议解析，物理层协议＋物理层数据（数据链路层协议＋数据链路层数据(网络层协议＋网络层数据（传输层协议比如tcp协议＋传输层数据（http协议和数据混合在一起))))

其他协议都是固定长度，从固定长度解析。http协议是不固定长度的。咱们前台f12打开看到的网络或network里边就是，属性固定但是属性的值不固定。所以长度不固定。在数据包中是通过换行符。最后根据换行符解析成字符串。

socket套接字工具，调用操作系统内核调用网卡驱动接收数据包进行一步步解析协议，解析数据时通过编码unicode - 16，解析成字符串。

反过来，把数据通过编码unicode - 16再通过一步步自动套接协议。封装成数组，最后调用操作系统内核调用网卡驱动将数据发出去。

3,数据往文件里边你存的时候只能以一种编码形式

4，文件输入输出源码里边是有一种编码机制，就是byte是每8位进行转换，unicode是每2位进行转换，转换asc||码，就去对应的库里边找转换后的。默认是asc||码。

5，![image-20220426095819461](C:\Users\qing  chun\AppData\Roaming\Typora\typora-user-images\image-20220426095819461.png)

6，一个类第一次用的时候需要类加载

7，方法执行的时候入栈，执行完以后就出栈了。

8，引用类型的变量a=x，相当于a内部的值的地址换成了新的地址

9，访问器能否保证线程安全

get方法，又叫访问器，默认线程是不安全的，别的线程调用get方法，相当于拿到了该属性的地址（值传递），当对他进行修改后，别人再读取就是不一样了。

10，子类继承父类，父类对象优先于子类生成，子类调用父类的构造方法，只要能帮父类完成初始化就可以。

11，类信息在方法区，类申明的对象在堆中，对于基本类型，局部变量在栈中，全局变量在堆中，引用类型是存在堆中。

12，二叉树和双向链表类结构相同

13现在运维搞虚拟化。使用的是VMware，或者docker - k8s![image-20220516092813658](C:\Users\qing  chun\AppData\Roaming\Typora\typora-user-images\image-20220516092813658.png)

14，自己买的一级域名如可以免费扩展二级三级域名；

哪怕是父子关系的域名也叫跨域。